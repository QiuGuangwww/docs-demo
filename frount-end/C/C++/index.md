# C与C++
## C
## 1.基础知识
### 1.1 顺序结构设计
#### 1.1.1 赋值语句
`“=”`在C语言中为赋值运算符，而不是“等于”的布尔类型判断，其一半形式为：  
```C
变量 = 表达式
```
**在赋值语句使用时，需要注意：**
（1）由于赋值运算`“=”`右边的表达式也可以是赋值表达式，因此，下列形式
```C
变量 = （变量 = 表达式）
```
是成立的，从而有嵌套的情形，这时候，语句应从右向左一一赋值。  
（2）进行赋值运算时，如果赋值运算符两边的数据类型不同，系统将自动进行类型转换，也就是将右边的数据类型转换为左边的。  

#### 1.1.2 运算符和表达式
|运算符类型 |具体运算符 |用法 |
|----------------|--------------------------------| ------------------------------|
|算数运算符|`+,-,*,/,%,++,- -` |用于数值运算|
|关系运算符|`>,<,==,<=,>=,!= `|用于比较运算 |
|逻辑操作符|与（`&&`）,或,非（`！`）|用于逻辑运算|
|位操作运算符|位与（`&`）,位或,位非（`~`）,异或(`^`),左移（`<<`），右移（`>>`）|按二进制进行计算|
|赋值运算符|`=,+=,-=,*=,/=,%=,&=,^=,>>=,<<=`|后面三种为复合位运算符|
|条件运算符|`x？a：b`|三目运算符，x真为a|
|逗号运算符|`，`|将若干表达式组合|
|指针运算符|取内容（`*`），取地址（`&`）|很重要
|求字节运算符|`sizeof`|用于计算数据类似占据字节数|
|特殊运算符|括号`（）`，下标`[]`等||  

一些运算符之间有优先级别：（从低到高）  
赋值运算符-->逻辑运算符-->关系运算符-->算数运算符  
常用函数与Python类似，略。  
#### 1.1.3 常量与变量
在 C 语言中，声明常量主要有两种常见的方式：使用 `#define` 预处理指令和使用 `const` 关键字。常量种类分为整型常量，实型常量，字符常量。  
 
 1.使用  `#define`  预处理指令：`#define` 是 C 语言的预处理指令，用于创建宏定义。通过 `#define` 可以定义一个标识符来代表一个常量值，这个标识符在编译前会被预处理器直接替换为对应的值。
 例：
```C
// 定义一个表示圆周率的常量
#define PI 3.14159
```
::: warning 
（1） `#define` 定义的常量没有类型信息，只是简单的文本替换，可能会导致一些潜在的问题，比如在复杂表达式中可能会出现意外的替换结果。  
（2）常量名通常使用大写字母，这是一种编程惯例，用于区分常量和变量。  
:::
2.使用 `const` 关键字：`const` 关键字用于声明一个只读的变量，即一旦初始化后，其值就不能再被修改。`const` 定义的常量具有类型信息，更符合现代编程的类型安全原则。
例：
```c
 // 定义一个表示重力加速度的常量
    const double GRAVITY = 9.8;
```
::: warning 
（1）`const` 定义的常量必须在声明时进行初始化，之后不能再对其进行赋值操作。  
（2）`const` 常量具有类型，编译器会进行类型检查，提高了代码的安全性和可读性。  
:::
#### 1.1.4 标准数据类型
**1. 整数类型**
整数类型用于表示整数，根据占用的内存空间和表示范围的不同，可分为以下几种：  
![P-R曲线](https://s21.ax1x.com/2025/03/15/pEacf1K.png)  
其他数组、指针等类型略。  

### 1.2 控制结构设计
#### 1.2.1 选择结构
在 C 语言中，选择结构用于根据条件的真假来决定执行不同的代码块。选择结构可以让程序根据不同的情况做出不同的决策，增强程序的灵活性和实用性。C 语言提供了两种主要的选择结构：`if` 语句和 `switch` 语句。下面将详细介绍这两种选择结构。  
**1.`if` 语句**  
`if` 语句是 C 语言中最基本的选择结构，它根据条件表达式的结果来决定是否执行特定的代码块。`if` 语句有以下几种形式：  
（1）简单 `if` 语句  
**语法**：  
```c
if (条件表达式) {
    // 当条件表达式为真（非零）时执行的代码块
}
```
（2）`if-else` 语句
```c
if (条件表达式) {
    // 当条件表达式为真（非零）时执行的代码块
} else {
    // 当条件表达式为假（零）时执行的代码块
}
```
（3） `if-else if-else` 语句 
```c
if (条件表达式 1) {
    // 当条件表达式 1 为真时执行的代码块
} else if (条件表达式 2) {
    // 当条件表达式 1 为假，条件表达式 2 为真时执行的代码块
} else if (条件表达式 3) {
    // 当条件表达式 1 和 2 都为假，条件表达式 3 为真时执行的代码块
}
// 可以有多个 else if 语句
else {
    // 当所有条件表达式都为假时执行的代码块
}
```
**2.switch语句**  
`switch` 语句用于根据一个表达式的值来选择执行多个代码块中的一个。它通常用于处理多个固定值的情况。  
**语法**：
```c
switch (表达式) {
    case 常量表达式 1:
        // 当表达式的值等于常量表达式 1 时执行的代码块
        break;
    case 常量表达式 2:
        // 当表达式的值等于常量表达式 2 时执行的代码块
        break;
    // 可以有多个 case 语句
    default:
        // 当表达式的值与所有 case 后面的常量表达式都不匹配时执行的代码块
        break;
}
```
#### 1.2.2 循环结构
在 C 语言中，循环结构用于重复执行一段代码，直到满足特定条件为止。循环结构可以提高代码的复用性和效率，避免代码的重复编写。C 语言提供了三种主要的循环结构：`for` 循环、`while` 循环和 `do-while` 循环，下面将详细介绍这三种循环结构。  
 **1. `for` 循环**  
`for` 循环是一种在已知循环次数的情况下非常常用的循环结构，它将循环控制的初始化、条件判断和循环变量更新都集中在一个语句中。  
```c
for (初始化表达式; 条件表达式; 更新表达式) {
    // 循环体，要重复执行的代码块
}
```
**2.while循环**
```c
while (条件表达式) {
    // 循环体，要重复执行的代码块
}
```
**3.do-while循环**
```c
do {
    // 循环体，要重复执行的代码块
} while (条件表达式);
```
::: tip 
`while` 循环先判断 `条件表达式` 的真假，只有当条件为真（非零）时，才会执行循环体中的代码。而`do-while` 循环先执行一次循环体中的代码，然后再判断 `条件表达式` 的真假，以决定是否继续下一次循环。
:::

**循环例题**（[Noip2012普及组第1题](https://www.luogu.com.cn/problem/P1075)）  
已知正整数$n$是两个不同的质数的乘积，试求出两者中较大的那个质数。  
输入一个正整数 $n$。输出一个正整数 $p$，即较大的那个质数。（$1≤n≤2×10^9$）  
```c
#include <stdio.h>
#include <math.h>
int main() {
    int n, x;
    scanf("%d", &n);
    int sqrtn = (int)floor(sqrt((double)n));//floor:向下取整
    for (int i = 2; i <= sqrtn; i++) {
        if (n % i == 0) {
            x = n / i;
        }
    }
    printf("%d\n", x);
    return 0;
}
```
## 2.数组
### 2.1 一维数组
**一维数组的定义：** 当数组中每个元素只带有一个下标，这样的数组称为一维数组。  
**数组的定义格式：** 
```c
类型标识符 数组名[常量表达式]
```
:::tip
（1）数组名的命名规则与变量名的命名规则一致。  
（2）常量表达式表示数组元素的个数，可以是常量和符号变量， **但不能是变量** 。
:::
例如：  
```c
int a[10];  //数组a的定义是合法的
int b[n];  //数组b的定义是非法的
```
::: warning
需要注意的是，a[10]有10个元素分别为a[0]-a[9]，a[10]并不属于该数组的空间范围。但是又因为C语言的 **“语言特性”** 写到a[10]的时候虽然数组越界了，但是并不会报错，而是会随机输出一个大数。所以防止数组越界是很重要的。
:::
**一维数组的引用：**   
一维数组的引用格式：
```c
数组名[下标]
```
 :::tip
 （1）下标可以是任意值为整型的表达式，该表达式里可包含变量和函数调用。但是应该注意下标值不要越界。  
 （2）在实际应用中，对下标变量的灵活控制有时会起到意想不到的作用。  
 （3）在 C 语言中，只能逐个引用数组元素，不能一次引用整个数组。  
 例如：int a[100],b[100];a=b;这样的写法是非法的。  
 （4）数组元素可以像同类型的普通变量那样使用，对其进行赋值和运算的操作。
 :::
 **数组越界：** 
 :::warning
 使用数组一定需要注意：  
 （1）数组元素下标值为非负整数！   
 （2）在定义元素个数的下标范围内使用！
 :::
 
 ### 2.2 二维数组
 **定义：** 与一维数组类似，当一维数组的元素的类型也是一维数组时，便构成了二维数组。二维数组定义的一般格式:
```c
数据类型 数组名[常量表达式1][常量表达式2]
```
例如:int a[4][10];    
a数组实际上是一个4行10列的表格，表格中可储存40个元素。第一行第一列对应a[0][0]，第n行第m列对应a[n-1][m-1]。  
:::tip
当定义的数组下标有多个时，我们称其为多维数组，下标的个数并不局限在一个或者两个，例如三维数组b和四维数组c:   
```c
int b[100][3][5];
int c[100][100][3][5];
```
:::
**二维数组的引用：**  与一维数组的区别在于必须给出两个下标，引用的格式为：
```c
<数组名>[下标1][下标2]
```
:::danger
注意不要越界！
:::

**二维数组的初始化：** 与一维数组类似，可以将每一行分开来写在各自括号里，也可以不分开，写在一个括号里：
```c
int a[4][2]={{1,0},{0,1}.{-1,0},{0,-1}};
int a1[4][2]={1,0,0,1,-1,0,0,-1};//尽量不要使用！
```

### 2.3 字符类型和字符数组
#### 2.3.1 字符类型
字符类型为由一个字符组成的字符常量或字符变量。  
```c
//字符常量定义
const 字符常量 = '字符'；
//字符变量定义
char 字符变量;
```
字符类型是一个有序类型，字符的大小顺序按其ASCII码的大小决定。  

 
#### 2.3.2 字符数组 
字符数组是指元素为字符的数组，其也有一维、二维和三维之分。  
 **字符数组的定义格式：** 字符数组定义格式和一般数组相同，所不同的是数组类型为字符型，第一个元素同样是从`ch1[0]`开始，而不是`ch1[1]`。具体格式如下：
 ```c
 [存储类型] char 数组名[常量表达式]...;
 //E.g
 char ch1[5];  //ch1是有5个字符元素的一维字符数组
 char ch2[3][5]; //ch2是有15个字符元素的二维字符数组
 ```
 **字符数组的赋值：** 分为两种方法，分别为 **用字符初始化** 和 **用字符串初始化**。  
 （1）用字符初始化：  
 例如：
 ```c
 char chr1[5]={'a','b','c','d','e'};
 ```
 初始值表中的每个数据项是一个字符，当初始值个数少于元素个数时，从首字符开始赋值，剩余元素默认为空字符。  
 字符数组中也可以存放若干个字符，也可以用来存放字符串。两者的 **区别** 是字符串有结束符`\0`，反过来说，在一维字符数组中存放带有结束符的若干个字符称为字符串。字符串是一维数组，但是一维字符数组不等于字符串。  
 （2）用字符串初始化：  
 用一个字符串初始化一个一维字符数组，可以写成：
 ```c
 char chr2[5]="abcd";
 ```
 :::warning
 使用此格式要注意字符串的长度应该小于字符数组的大小或等于字符数组的大小 **减1** ，因为c语言会自动在最后补一个`\0`。  
 :::
 同理，对二维字符数组来说，可存放若干个字符串。可使用由若干个字符数组组成的初始值表给二位字符数组初始化。  
 （3）数组元素赋值：  
 单独给每个元素赋一个字符值。例如：  
 ```c
 char chr[3];
 chr[0] = 'a';chr[1] = 'b';chr[2] = 'c';
 ```
 对多维字符数组也同理。  
 :::info
 **字符常量和字符串常量的区别**  
 （1）两者的定界符不同，字符常量由 **单引号** 括起来，字符串常量由 **双引号** 括起来；   
 （2）字符常量只能是单个字符，而字符串常量则可以是多个字符；  
 （3）可以把一个字符常量赋值给一个字符变量，但不能把一个字符串常量赋给一个字符串变量；  
 （4）字符常量占一个字节，而字符串常量占用字节数等于字符串的字节数加1（末尾的`\0`占据一个字节）。
 :::
 
#### 2.3.3 字符串输入输出 
 
 * **输入：**  
 * 使用`scanf`函数：格式控制字符串中使用`%s`来读取字符串。当使用`scanf`输入字符串时，它会从输入流中读取字符，直到遇到空格、制表符、换行符或者文件结束符为止。
```c
char str[20];
    printf("请输入一个字符串：");
    scanf("%s", str);
    printf("你输入的字符串是：%s\n", str);
```
:::warning
注意，`scanf`函数在读取字符串时不会检查数组是否越界，所以要确保输入的字符串长度不超过字符数组的大小，否则会导致缓冲区溢出，引发未定义行为。
:::
* 使用`gets`函数（不推荐）:`gets`函数从标准输入流中读取一行字符串，包括空格，并将其存储到字符数组中，它会自动在字符串末尾添加`\0`。
 ```c
char str[20];
    printf("请输入一个字符串：");
    gets(str);
    printf("你输入的字符串是：%s\n", str);
```
:::warning
由于`gets`函数不限制输入的字符数量，容易导致缓冲区溢出，存在安全隐患，因此在实际应用中不推荐使用。
:::
* 使用`fgets`函数:`fgets`函数可以从指定的文件流中读取一行字符串，也常用于从标准输入流`stdin`中读取字符串。它的优点是可以指定读取的字符数量，从而避免缓冲区溢出。
 ```c
char str[20];
    printf("请输入一个字符串：");
    fgets(str, 20, stdin);// 从标准输入读取一行字符串，最多读取 19 个字符（留一个位置给 '\0'）
    // fgets会读取换行符，所以如果需要去除换行符，可以使用以下方法
    if (str[strlen(str) - 1] == '\n') {
        str[strlen(str) - 1] = '\0';
    }
    printf("你输入的字符串是：%s\n", str);
```
 * **输出：**  
 * 使用`printf`函数：-   格式控制字符串中使用`%s`来输出字符串。`printf`函数会从给定的字符数组起始地址开始，依次输出字符，直到遇到`\0`结束符为止。
 ```c
	char str[] = "Hello, World!";
    printf("字符串为：%s\n", str);
```
* 使用`puts`函数：`puts`函数用于将一个字符串输出到标准输出流，并在输出完字符串后自动换行。
```c
	char str[] = "Hello, World!";
    puts(str);
```
* 使用`fputs`函数：`fputs`函数可以将一个字符串输出到指定的文件流中，也可以输出到标准输出流`stdout`。
 ```c
	char str[] = "Hello, World!";
    fputs(str, stdout);
```

**字符串String类型：** C语言并无内置string类型，等到C++笔记再进行讨论。

### 2.4 字符串处理函数  
#### 2.4.1.字符串长度计算：strlen  
* **功能：** 计算字符串的长度，即字符串中字符的个数。返回字符串的长度，格式为size_t。
:::warning
**strlen**得到的字符个数不包括字符串结束符`\0`
:::
示例代码：  
```c
char str[] = "Hello, World!";
size_t len = strlen(str);
printf("字符串的长度是: %zu\n", len);//%zu是size_t的输出符，实际上，用%d也是可以的，也更符合常识。
```
#### 2.4.2.字符串复制：strcpy与strncpy
* （1）**strcpy**
* **功能：** 将一个字符串复制到另一个字符数组中。返回值是一个指向目标字符数组的指针。  
:::info
原字符串 `dest` 末尾的 `'\0'` 会被覆盖，当 `src` 字符串复制完成后，`strcat` 会在新字符串的末尾添加一个 `'\0'`，以此来表示新字符串的结束。
:::
示例代码：
```c
char src[] = "Hello";
char dest[10];
strcpy(dest, src);
printf("复制后的字符串: %s\n", dest);//%s是用于处理字符串的
```   

* （2）**strncpy**
* **功能：** 将源字符串的前 `n` 个字符复制到目标字符数组中。 返回指向目标字符数组的指针。 
:::warning
如果源字符串的长度小于 `n`，则在目标字符数组后面填充 `\0` 直到达到 `n` 个字符；如果源字符串的长度大于等于 `n`，则不会自动添加 `\0`。注意不要越界！
:::
示例代码：
```c
char src[] = "Hello";
char dest[3];
strncpy(dest, src, 2);
dest[2] = '\0';  // 手动添加字符串结束符
printf("复制后的字符串: %s\n", dest);
```
#### 2.4.3.字符串连接：strcat与strncat
* （1）**strcat**
* **功能：** 将一个字符串连接到另一个字符串的末尾。返回指向目标字符数组的指针。 
示例代码：
```c
char dest[20] = "Hello, ";
char src[] = "World!";
strcat(dest, src);
printf("连接后的字符串: %s\n", dest);
```

* （2）**strncat**
* **功能：** 将源字符串的前 `n` 个字符连接到目标字符数组的末尾。 返回指向目标字符数组的指针。 
:::warning
连接后会自动在结果字符串末尾添加 `'\0'`。
:::
示例代码：
```c
char dest[20] = "Hello, ";
char src[] = "World!";
strncat(dest, src, 3);
printf("连接后的字符串: %s\n", dest);
```
####  2.4.4.字符串比较：strcmp与 strncmp
* （1）**strcmp**
* **功能：** 比较两个字符串的大小($ASC2$)。如果 `s1` 小于 `s2`，返回一个负整数；如果 `s1` 等于 `s2`，返回 0；如果 `s1` 大于 `s2`，返回一个正整数。（返回值通常是两个不同字符的$ASC2$码值之差）
:::tip
这个函数是逐个字符比较，只要遇到相同位置返回值不为0的就不会继续比较。
:::
示例代码：
```c
char str1[] = "apple";
char str2[] = "banana";
int result = strcmp(str1, str2);
if (result < 0) {
    printf("%s 小于 %s\n", str1, str2);
} else if (result == 0) {
    printf("%s 等于 %s\n", str1, str2);
} else {
    printf("%s 大于 %s\n", str1, str2);
}//比较首字母a和b即可以得到apple<banana
```

* （2）**strncmp**
* **功能：** 比较两个字符串的前 `n` 个字符的大小。 与 `strcmp` 类似，根据前 `n` 个字符的比较结果返回相应的值。
示例代码：
```c
char str1[] = "apple";
char str2[] = "applet";
int result = strncmp(str1, str2, 3);
if (result == 0) {
    printf("前 3 个字符相等\n");
}
```

#### 2.4.5.字符串查找：strchr与strstr
* （1）**strchr**
* **功能：** 在字符串中查找指定 **字符** 第一次出现的位置。如果找到，返回指向该字符的指针；如果未找到，返回 `NULL`。
示例代码：
```c
char str[] = "Hello, World!";
char *pos = strchr(str, 'o');
if (pos != NULL) {
    printf("字符 'o' 第一次出现的位置是: %ld\n", pos - str);
} else {
    printf("未找到字符 'o'\n");
}
```

* （2）**strstr**
* **功能：** 在字符串中查找指定子字符串第一次出现的位置。如果找到，返回指向子字符串的指针；如果未找到，返回 `NULL`。
示例代码：
```c
char str[] = "Hello,World!";
char *sub_str = "World";
char *pos = strstr(str, sub_str);
if (pos != NULL) {
    printf("子字符串 '%s' 第一次出现的位置是: %ld\n", sub_str, pos - str);
} else {
    printf("未找到子字符串 '%s'\n", sub_str);
}
```
#### 2.4.6.字符串分割：strtok
* **功能：** 将字符串按指定的分隔符进行分割。返回分割出的子字符串的指针，如果没有更多的子字符串，返回 `NULL`。
示例代码：
```c
char str[] = "Hello,World,How,Are,You";
char *token = strtok(str, ",");//*是指针运算符，在后面会提到
while (token != NULL) {
    printf("%s\n", token);
    token = strtok(NULL, ",");
}
```
## 3.函数
### 3.1  函数的定义
**语法：**
```c
数据类型 函数名(形式参数表)
{
	函数体  //执行语句
}
 ```
 :::info
 * 函数的数据类型是函数的返回值类型（若数据类型为void，则无返回值）  
 * 函数名是标识符，一个程序中除了主函数名必须为main外，其余函数的名字可以任意选取，最好取有助于记忆的名字    
 * 形式参数（简称 **形参** ）表可以是空的（无参函数），也可以有多个形参，形参间用逗号隔开，不管有无参数，函数名后的圆括号都必须要有。形参必须有 **类型说明** ，形参可以是变量名，数组名或指针名，其作用是实现主调函数与被调函数之间的关系、
 * 函数中最外层一对花括号`{}`括起来的语句组成了一个函数的函数体。函数体实际上是一个复合语句，它可以没有任何类型说明而只有语句，也可以两者都没有，即空函数
 * 函数 **不允许嵌套定义** 。在一个函数内定义另一个函数是非法的，但是 **允许嵌套使用** 
 :::
 **举例：**
 ```c
 //定义一个函数，返回两个数中的较大数
 int max(int x,int y){
	 return x>y?x:y //三目运算符
}
```
### 3.2 函数的形式
函数的形式从结构上说有三种：无参函数，有参函数和空函数。  
**（1）无参函数**
* 顾名思义为没有参数传递的函数，无参函数一般不需要带回函数值，所以函数类型说明为void  

**（2）有参函数**
* 有参数传递，一般需要带回函数值，例如`int max(int x,int y)`  

**（3）有参函数**
* 函数体只有一对花括号，花括号内没有任何语句，只起到占位的作用，方便后面添加函数

### 3.3 函数的声明和调用
#### 3.3.1 函数的声明
调用函数之前需要声明函数原型，在主调函数中或所有函数定义之前，按照如下形式声明：
```c
类型说明符 被调函数名(含类型说明的参数表)
```
如果是在所有函数定义之前声明了函数原型，那么该函数原型在本程序文件中任意地方都有效，但是要是在某个主调函数内部声明了函数原型，那么该原型就只在这个函数内部有效。  
下面对`js()`函数原型声明是合法的。
```c
int js(int n);
int js(int);//也是对的
```
#### 3.3.2 函数的调用
声明了函数原型后，我们便可以按照如下形式调用函数:
```c
函数名（实参列表） 
```
实参列表中应该给出与函数原型形参列表相同个数、类型相同的实参。在主调函数中的参数称为实参，实参一般具有确定的值，可以是常量，表达式，也可以是已有确定值的变量、数组或指针名。函数调用可以作为一条语句，此时函数可以无返回值；函数调用也可以出现在表达式中，这时就必须有一个明确的返回值。

#### 3.3.3 函数的返回值
-   函数返回值由`return`语句给出，一个函数只能有一个返回值。
-   返回值类型在函数定义时指定，如`int func()`返回整型，`void func()`表示无返回值。
-   若未指定返回值类型，默认是`int`。返回值可用于赋值、传参等后续操作。
- 函数的返回语句也可以是`return`，此时函数无返回值，而只是把流程转向主调函数。

### 3.4 函数的传值与传址调用
#### 3.4.1 函数的传值调用
**特点：** 将调用函数的实参表中的实参值依次传递给被调用函数的形参表中的形参。要求个数相等，类型相同。函数的调用过程实际上是对栈（在数据结构中会介绍）。  
传值调用是将实参的数据值传给形参，但是实参本身并不发生改变，简称 **单向值传递** ，下面以一个失败的$swap$函数举例：（$swap$意为交换，要交换两个数字的值）
```c
void swap(int a,int b){
	int temp=a;a=b;b=temp;//交换a和b的值
}
int main(){
	int c=1,d=2;
	swap(c,d);
	scanf("%d,%d",c,d);
	return 0;
}
```
当我们运行这个程序后，发现$c$和$d$依然是1和2，说明它们的值并没有被成功的交换，因为我们只是把$c$和$d$的**值**传递给了形式参数$a$和$b$，$c$和$d$本身没有发生任何变化，即实参的值未发生改变，交换失败。那么如何交换成功呢？

#### 3.4.2 函数的传址调用（C++）
顾名思义，传址调用就是传递的**地址**，我们知道数据在计算机内是通过**内存空间**存储的，每个元素都有它的一块**地址**，我们将实参的地址传递给形参，那么随着形参的地址交换，不就可以成功的把实际参数的地址也交换了吗？——确实如此：
```C++
void swap(int &a,int &b){//&是取地址符，得到的是地址
	int temp=a;a=b;b=temp;//交换a和b的值
}
int main(){
	int c=1,d=2;
	swap(c,d);
	scanf("%d,%d",c,d);
	return 0;
}
```
:::tip 注意
上面这个程序在C中是错误的，因为C不支持引用，但是C++支持，所以C++中是可以的。
:::
可以发现输出结构确实变成了2和1，这就说明这个函数生效了。这就是函数的传址调用。

### 3.5 全局变量、局部变量以及其作用域
#### 3.5.1  全局变量
** 定义**
全局变量是在所有函数外部定义的变量。以下是一个简单示例：
```c
#include <stdio.h>
// 定义全局变量
int globalVar = 10;
void func() {
    // 在函数中可以访问全局变量
    printf("在 func 函数中，全局变量 globalVar 的值为: %d\n", globalVar);
}
int main() {
    // 在 main 函数中也可以访问全局变量
    printf("在 main 函数中，全局变量 globalVar 的值为: %d\n", globalVar);
    func();
    return 0;
}
```
在上述代码中，`globalVar` 就是一个全局变量，它定义在所有函数（`func` 和 `main`）之外。  
* **作用域**
- 全局变量的作用域是从它的定义位置开始，到整个源文件的结束。这意味着在定义位置之后的所有函数都可以直接访问和修改这个全局变量。不过，如果在其他源文件中想使用该全局变量，需要使用 `extern` 关键字进行声明。  
* **生命周期**
- 全局变量的生命周期是整个程序的运行期间。程序开始运行时，全局变量就被创建并分配内存空间；当程序结束时，全局变量所占的内存空间才会被释放。  
:::warning
由于全局变量可以被多个函数访问和修改，可能会导致程序的可维护性和可读性降低，也容易引发意外的副作用。比如多个函数同时修改全局变量，可能会让程序的状态变得难以跟踪和调试。
:::
#### 3.5.2  局部变量
* **定义**
局部变量是在函数内部或者代码块（如 `if`、`for`、`while` 等语句块）内部定义的变量。示例如下：
```c
#include <stdio.h>
void func() {
    // 定义局部变量
    int localVar = 20;
    printf("在 func 函数中，局部变量 localVar 的值为: %d\n", localVar);
}
int main() {
    func();
    // 下面这行代码会报错，因为 localVar 是 func 函数的局部变量，main 函数无法访问
    // printf("在 main 函数中访问 localVar: %d\n", localVar);
    return 0;
}
```
在 `func` 函数内部定义的 `localVar` 就是一个局部变量。
 * **作用域**
- 局部变量的作用域仅限于定义它的函数或者代码块内部。在函数或代码块外部，无法访问这个局部变量。例如在上面的代码中，`main` 函数就不能访问 `func` 函数内部定义的 `localVar`。

* **生命周期**
- 局部变量的生命周期从进入定义它的函数或代码块开始，到离开该函数或代码块结束。当程序执行到定义局部变量的位置时，系统会为该变量分配内存空间；当离开该函数或代码块时，系统会自动释放该变量所占的内存空间。
:::warning
局部变量可以避免不同函数之间的变量命名冲突，提高代码的安全性和可维护性。不同函数内部可以定义同名的局部变量，它们彼此独立，互不影响。
:::

:::danger
全局变量数组初始全部为0，局部变量值是随机的，要初始化初始值，局部变量受栈空间大小限制，大数组需要注意，但是全局变量则可以开大数组。
:::

### 3.6 函数的递归
何为递归？即第$n$项和前面几项的关系。以阶乘函数为例，一般来说，实现一个阶乘函数我们可能会考虑使用循环：
```c
// 定义阶乘函数
int factorial(int n) {
    // 用于存储阶乘结果的变量，初始化为 1
    int result = 1;
    // 如果输入的 n 小于 0，阶乘无定义，这里简单返回 1
    if (n < 0) {
        return 1;
    }
    // 使用 for 循环计算阶乘
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}
```
但是不难注意到，阶乘的第$n$项和其第$n-1$项有着很显然的关系：
$$
factorial(n)=n*factorial(n-1)
$$
于是我们也可以把阶乘函数更加简洁的写成下面这个形式：
```c
// 递归实现阶乘函数
int factorial(int n) {
    if (n == 0) {
        return 1;// 基本情况：0 的阶乘为 1
    } 
    else {
        return n * factorial(n - 1);
    }
}
```
这就是递归的魅力。

**例题【[# P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)】**  
此题主要是一个递归的思想，语言并不重要，由于用c实现需要高精度的知识，下面用Python解决：
::: code-group
```Python
n = int(input())
if (n == 0):
    print(0)
    exit(0)
a = [1, 1, 2]
for i in range(0, n):
    a[2] = a[0] + a[1]
    a[0] = a[1]
    a[1] = a[2]
    pass
print(a[0])
```

```C++
#include<bits/stdc++.h>
#define N 250//2000位够了，250*8
using namespace std;
int  f[3][N+10],g;
int n;
int main()
{
	f[0][N]=1;f[1][N]=1;scanf("%d",&n);if(!n){puts("0");return 0;}//0要特判
	for(int i=2;i<=n;i++)
	 for(int j=N;j>0;j--)
	  {
	 	f[i%3][j]=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)%100000000;
	    g=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)/100000000;//8个0，别漏了
	  }
	int j=1;
	while(!f[n%3][j]&&j<N) j++;//处理前导0
	for(int i=j;i<=N;i++)
	{
		if(i!=j){//一定别漏了前面这句
		if(f[n%3][i]<1e7) putchar(48);
		if(f[n%3][i]<1e6) putchar(48);
		if(f[n%3][i]<1e5) putchar(48);
		if(f[n%3][i]<1e4) putchar(48);
		if(f[n%3][i]<1e3) putchar(48);
		if(f[n%3][i]<1e2) putchar(48);
		if(f[n%3][i]<1e1) putchar(48);}//补足前导0
		printf("%d",f[n%3][i]);//输出
	}
}
```
:::

## 4.指针与链表

### 4.1 指针变量

#### 4.1.1 指针定义与初始化
**指针的概念：**   
- 指针是一个变量，其存储的是另外一个变量的内存地址。通过指针，我们可以**间接**访问和操作其他变量。  

**指针变量的定义与初始化：**  
- 定义指针变量的一般形式为：
```c
类型 *指针变量名;
```
例如`int *p`定义了一个指向`int`类型变量的指针`p`。我们将通过以下例子来看看指针和普通变量有什么不同：   
**1.普通变量定义：**   
```c
int a=3;
```
定义了变量$a$，是int类型，值为3。内存中有一块内存空间存放$a$的值，对$a$的操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用**取地址操作符**“&”对$a$运算得到：`&a`。  
**2.指针变量定义：**   
```c
int *p=NULL;
```
定义了一个指针变量$p$，其指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。   
**3.给指针变量$p$赋值：**
```c
p=&a;
```
即把$a$变量的内存空间地址给了$p$，显然，直接对$p$存取，操作的是地址。通过这个地址间接的操作，才是整数3。即前后分为3步：$p$是指针变量指向的是内存地址，内存地址指向的是数值3，而$a$自身就是一个内存地址，其直接指向3。我们输入$a$时用的是`scanf(“%d”,&a)`，而&就是取地址运算符，存储在相应的地址。而$p$的定义是`p=&a`，$p$不直接指向3，而指向$a$，$a$再指向3，所以我们需要再用间接运算符*，此时，`*p=3`。将整型变量$a$的地址赋予$p$有两种方式：  

- 1.指针变量初始化的方法
```c
int a;int *p=&a;//注意先后顺序，是将a的地址赋值给p 而非*p
```
- 2.赋值语句的的方法
```c
int a;int *p;p=&a;
```

:::warning
不允许把一个数赋予指针变量，故如下的赋值是错误的：
```c
int *p;p=1000;
```
被赋值的指针变量前不能再加“ $*$ ”说明符，故如下的赋值也是错误的：
```c
*p=&a;
```
:::
指针变量直接存取的是内存地址：
```c
printf("%d",p)//输出的可能是0x4097ce（地址位置）
```
间接存取的才是储存类型的值：
```c
printf("%d",*p)//正确输出值
```
指针变量和普通变量一样，使用之前不仅要定义说明，而且必须被赋予具体的值，**未经赋值的指针变量不能使用。**    
下面举一个简单的例子：  
**例：** 输入两个不同的数，通过指针对两个数进行相加和相乘，并输出
```c
#include <stdio.h>
int main(){
	int a,b,s,t,*pa,*pb;
	pa=&a;pb=&b;//pa和pb指向地址，用取地址符赋予他们地址
	a=10;b=20;
	s=*pa+*pb//实际上就是a+b，因为*pa=a，*pb=b
	t=*pa * *pb；
	printf("a=%d,b=%d\n",*pa,*pb);
	printf("s=%d,t=%d\n",s,t);
	return 0;
}
```

#### 4.1.2 指针的引用和运算
一般的，我们可以这样看指针（`int *p`）与普通变量的关系（`int a`）
  
  |指针与普通变量对比   |
  |----------------|
  |p ———————— &a|
  |*p ———————— a|
  |*p=3———————a=3 |

  
下面介绍一些运算：    
**1.指针变量的初始化**  
- （1）`int *p=NULL`，NULL是特殊的地址0，叫做零指针。
- （2）`int a；int *p=&a;`，p初始化为a的地址。
- （3）【C++中才有】`int *p=new(int);`，申请一个空间给p，*p的内容不确定。  

**2.指针变量的加减运算**   
指针变量的内容是内存地址，其有两个常用的运算：加法和减法，这两个运算一般都是配合**数组**操作的。  
**例：** 输入$N$个整数，使用指针变量访问输出。
::: code-group
```C
#include <stdio.h>
int a[101],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	int *p=&a[1];
	for(int i=1;i<=n;i++){
		printf("%d",*p);
		p++;
	}
	return 0;
}
```

```C++
#include <cstdio>
using namespace std;
int a[101],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	int *p=&a[1];
	for(int i=1;i<=n;i++){
		printf("%d",*p);
		p++;
	}
	return 0;
}
```
:::

:::tip
“p++”的意思是“广义的加1”，并不是p的值（地址）加上一个数字1，而是根据类型int增加sizeof(int)，即正好“跳过”了一个整数的空间，从而到达下一个整数。  
类似的：  
①“p- -”就是向前跳过一个整数的空间，达到前一个整数；  
②（p+3）就是指向后面第三个整数的地址。
:::

#### 4.1.3 无类型指针
有时候，一个指针根据不同情况，指向的内容是不同类型的值，我们可以先不明确它的类型，定义一个无类型指针，后面再根据需要使用强制类型转换的方法明确它的类型。  
**语法：**  `void *`   
**例：** 
```c
#include <stdio.h>
int main() {
    int num = 10;
    float f = 3.14;
    void *ptr;
    ptr = &num;  // 指向 int 类型变量
    printf("%d",*ptr);
    ptr = &f;    // 指向 float 类型变量
    printf("%d",*ptr);
    return 0;
}
```
#### 4.1.4 多重指针
指针自身也是一种数据类型，那么就应该有指针可以指向指针，这就叫做多重指针。  
**例：**  
```c
#include <stdio.h>
int main() {
    int num = 10;
    int *ptr = &num;  // 一级指针，指向 int 类型变量
    int **pptr = &ptr;  // 二级指针，指向一级指针 ptr
    printf("num 的值: %d\n", num);
    printf("通过一级指针访问 num 的值: %d\n", *ptr);
    printf("通过二级指针访问 num 的值: %d\n", **pptr);
    return 0;
}
```

### 4.2 指针与数组
#### 4.2.1 指针与数组的关系
指向数组的指针变量称为数组指针变量。一个数组是一块**连续的内存单元**组成的，**数组名就是这块连续内存单元的首地址**。一个数组元素的首地址就是指它所占有的几个内存单元的首地址。一个指针变量既可以指向一个数组，也可以指向一个数组元素。可以把数组名或第一个元素的地址赋予它。这样，如果要使指针变量指向第$i$号元素，可以把$i$元素的首地址赋予它，或把数组名加$i$赋予它。
#### 4.2.2 指向数组的指针
**一般形式：** 与普通的指针相同，为
```c
类型说明符 *指针变量名
```
其中类型说明符表示所指向数组的类型。  
引入了指针变量后，我们可以用两种方法访问数组元素：  
- （1）下标法：定义了`int a[5];int *pa=a`，用`pa[i]`的形式访问$a$的数组元素。
- （2）指针法：采用`*(pa+i)`的形式，用间接访问的方法来访问数组元素。  

::: code-group
```C
#include <stdio.h>
int main(){
	int a[5],i,*pa=a; //定义整型数组和指针，*pa=a可以在下一行单独写成pa=a
	for(i=0;i<5;i++){
		scanf("%d",a+i);//可写成pa+i或&a[i]
	}
	for(i=0;i<5;i++){
		printf("a[%d]=%d\n",i,*(a+i));
		//指针访问数组，可写成*(pa+i)或pa[i]或a[i]
	}
	return 0;
}
```

```C++
#include <cstdio>
using namespace std;
int main(){
	int a[5],i,*pa=a; //定义整型数组和指针，*pa=a可以在下一行单独写成pa=a
	for(i=0;i<5;i++){
		scanf("%d",a+i);//可写成pa+i或&a[i]
	}
	for(i=0;i<5;i++){
		printf("a[%d]=%d\n",i,*(a+i));
		//指针访问数组，可写成*(pa+i)或pa[i]或a[i]
	}
	return 0;
```
:::

:::tip
- ①需要注意的是，**数组名a**自身就是一个地址！所以可以由`pa=a`的写法！
- ②由①，可以直接拿a当指针用，a指向的是数组的开始元素，a+i是指向数组的第i个元素的指针。
- ③指针变量pa是变量，是可以变化的，但是数组名a是静态的变量名，不可以变！即pa=pa+2是合法的，指向pa往后两个的元素，但是a=a+2是不合法的。
- ④最早我们在使用scanf的时候其实就使用了指针，读入一个变量需要加取地址符号&传递给scanf函数一个指针。而对于数组，数组名就可以直接当作指针。
:::
#### 4.2.3 指针也可以看成数组名
在C语言中，这很麻烦，C++中我们可以直接用new int来为指针申请连续的内存空间，但是C语言不能这样做，C语言中我们使用malloc函数来分配指定大小的内存块，malloc函数返回指向该内存块起始地址的void*指针，通常需要将其转换为具体类型的指针。而C++中，用new int则会方便很多，具体到后面C++章节再详细介绍，下面以一个计算前缀和数组的例子作为动态数组的介绍：
**例：**
::: code-group
```C
#include <stdio.h>
#include <stdlib.h>
int main() {
    int n;
    int *a;  // 定义指针变量 a，后续当作数组使用
    scanf("%d", &n);
    // 动态分配 n + 1 个 int 类型的内存空间
    a = (int *)malloc((n + 1) * sizeof(int));
    if (a == NULL) {
        printf("内存分配失败\n");// 若内存分配失败，输出错误信息并终止程序
        return 1;
    }
    for (int i = 1; i <= n; i++) {scanf("%d", &a[i]);}
    for (int i = 2; i <= n; i++) {a[i] += a[i - 1];}
    for (int i = 1; i <= n; i++) {printf("%d ", a[i]);}
    printf("\n");
    free(a);// 释放动态分配的内存
    return 0;
}
```

```C++
#include <cstdio>
using namespace std;
int n;
int *a;//定义指针变量a，后面直接当数组名使用
int main(){
	scanf("%d",&n);
	a=new int[n+1];//申请了连续的n+1个int型空间
	for(int i=1;i<=n;i++){scanf("%d",&a[i]);}
	for(int i=2;i<=n;i++){a[i]+=a[i-1];}//i从2开始防止越界
	for(int i=1;i<=n;i++){printf("%d",a[i]);}
	delete []a;//释放申请的a的空间
	return 0;
```
:::

### 4.3 指针与字符串
#### 4.3.1 字符串的表示形式
在C语言中，我们可以用两种方法访问字符串。  
- （1）用字符数组存放一个字符串，然后输出该字符串。
```c
int main(){
	char str[]="I love China! ";
	printf("%s\n",str);
}
```
- （2）用字符指针指向一个字符串。可以不定义字符数组，而定义一个字符指针。用字符指针指向字符串中的字符。
```c
int main(){
	char *str="I love China! ";
	printf("%s\n",str);
}
```
在这里，我们没有定义字符数组，而是在程序中定义了一个字符指针变量str，用字符串"I love China! "对它进行初始化。C语言（事实上C++也是）对字符串常量是按照字符数组处理的，在内存中开辟了一个字符数组用来存放该字符串数量。对字符指针变量初始化，实际上是把字符串第一个元素的地址赋给str。有人认为str是一个字符串变量，以为在定义的时候把"I love China! "这几个字符赋给该字符串变量是不对的。   
实际上，`char *str="I love China! ";`   
等价于`char *str；str="I love China! ";`     
可以看到，str被定义为了一个**指针变量**，指向字符串数据，请注意：它只是指向了一个字符变量或其他字符类型数据，不能同时指向多个字符数据，更不是把"I love China! "这些字符存放到str中（指针变量只能存放地址）。只是把"I love China! "的第一个字符的地址赋给了指针变量str。  
在输出的时候，用`printf("%s\n",str);`    
其中%s是输出字符串时用的格式符，在输出项中给出字符指针变量名，则系统先输出它所指向的第一个字符数据，然后自动使str+1，直到遇到“\0”为止。  
:::tip
可以通过字符数组名或者字符指针变量输出一个字符串，但是对数值型数组，是不能这样做的！！
:::

#### 4.3.2 字符串指针作函数参数
将一个字符串从一个函数传递到另外一个函数，可以用地址传递的方法，即用字符串数组名作参数或用指向字符的指针变量作参数。在被调用的函数中可以改变字符串的内容，在主调函数中可以得到被改变了的字符串。   
**例：** 输入一个长度最大为100的字符串，以字符数组的方式储存，再将字符串倒序储存，输出倒序储存后的字符串。（用指针做） 
::: code-group
```C
#include <stdio.h>
#include <string.h>
// 交换两个字符的位置
void swapp(char *a, char *b) {//写成&a，&b也行，见C++写法
    char t;
    t = *a;
    *a = *b;
    *b = t;
}
void work(char *str) {
    int len = strlen(str);
    for (int i = 0; i <= len / 2; i++) {
        swapp(&str[i], &str[len - i - 1]);  // 传递字符地址进行交换
    }
}
int main() {
    char s[110];
	gets(s);//现在一般替换为fgets
    work(s);
    printf("%s\n", s);
    return 0;
}
```

```C++ 
#include <cstdio>
#include <cstring>
using namespace std;
void swapp(char &a,char &b){//交换两个字符的位置
	char t;
	t=a;
	a=b;
	b=t;
}
void work(char *str){
	int len=strlen(str);//原型是size_t strlen(const char * str)
	for(int i=0;i<=len/2;++i){swapp(str[i],str[len-i-1]);}//首尾交换
}
int main(){
	char s[110];
	char *str=s;
	gets(s);//现在一般替换为fgets
	work(str);
	printf("%s",s);
	return 0;
}
```
:::

### 4.4 指针与函数
#### 4.4.1 指针作为函数参数
我们在前面函数部分探讨函数传值调用和传址调用的时候就讨论过类似的问题。在函数章节中，我们把数字作为参数传入函数中，实际上就是使用了传递指针（即传递数组首地址）的方法。通过首地址，我们可以访问数组中的任意一个元素。  
对于指向其他变量类型的指针，我们可以用同样的方式处理。我们再次来探讨一遍关于swap函数的例子。  
```c
void swap(int *x,int *y){
	int t=*x;
	*x=*y;
	*y=t;
}
```
这时，我们可以在其他函数中使用这个函数：
```c
int a=5,b=3;
swap(&a.&b);
printf("a=%d,b=%d",a,b);
//输出结果为a=3,b=5
```
在这个过程中，我们先将a和b的地址传给函数，然后在函数中通过地址得到变量a和b的值，并且对它们进行修改。当退出函数时，a和b的值就已经交换了。  
这里有一点值得我们注意，这点在上面的函数章节已经提过了，不加$*$和&的话a和b的值并不会互换。因为形参和实参的关系。我们不使用指针的话，交换的只是传递给形参的值，主调函数中的实参值并不会交换。  
#### 4.4.2 函数返回指针
一个函数可以返回字符值、整数值、实型值等，也可以返回指针联系的数据（即地址）。  
返回指针值的函数的一般定义形式为：  
```c
类型名 * 函数名(参数列表)；
//例如：
int *a(int a,int b)
```
a是函数名，调用它后得到了一个指向整型数据的指针（地址）。x和y是函数a的形参，为整型。
:::warning
在*a的两侧没有括号；在a的两侧分别为$*$运算符和（）运算符，由于（）的优先级高于$*$，a先与（）结合。在函数面前有一个$*$表示此函数是返回指针类型的函数，前面的int表示返回的指针指向整型变量。这点容易搞错。
:::

### 4.5 函数指针和函数指针数组
一个指针变量通过指向不同的整型变量的地址，就可以对其他的变量操作。  
程序中不仅数据是存放在内存空间中，代码也同样存放在内存空间中。具体讲，C和C++的函数也保存在内存中，函数的入口地址也同样可以使用指针来访问。  
另一方面，有些函数在编写时对要调用的辅助函数尚未确定，在执行时才能根据情况为其传递辅助函数的地址。比如在C语言中，qsort函数的调用：`qsort(arr,n,sizeof(int),cmp)`，其中的cmp函数是我们根据需要传给sort的，其实就是传递了函数指针。  
**函数指针的基本操作有3个：**   
- （1）声明函数指针    
声明要指定函数的返回类型以及函数的参数列表，和函数原型差不多。**例如：**
```c
int test(int); //函数的原型
int (*fp)(int); //相应的指针声明
//要注意不能写成：
int *fp(int);//写成这样计算机会处理成声明一个fp(int)的函数，返回类型为int*
```
- （2）获取函数地址
获取函数地址很简单，只需使用函数名即可，例如，`fp=test`。  
这表明函数名和数组名一样，可以看作是指针。   
- （3）使用函数指针来调用函数  
类似普通变量指针，可以用`(*fp)`来间接调用指向的函数，但C++也允许像使用函数名一样使用fp。**（C语言不允许）**     
函数指针还有另一种结合typedef的声明方式：
**例：**
::: code-group
```C
#include <stdio.h>
int sum(int a, int b) {
    return a + b;
}
// 使用typedef定义函数指针类型，该函数指针指向的函数有两个int型参数，返回值为int型
typedef int (*LP)(int, int); 
int main() {
    LP p = add; // 定义函数指针变量并指向add函数
    int result = p(2, 5); // 通过函数指针调用函数
    printf("%d\n", result); //输出7
    return 0;
} 
```
```C++
#include <iostream>
using namespace std;
int sum(int a, int b) {
    return a + b;
}
// 使用typedef定义函数指针类型，该函数指针指向的函数有两个int型参数，返回值为int型
typedef int (*LP)(int, int); 
int main() {
    LP p = add; // 定义函数指针变量并指向add函数
    cout<<p(2,5);
    return 0;
} 
```
:::

## 5.结构体
### 5.1 结构体的定义和操作
#### 5.1.1定义结构体及结构体变量
- （1）定义结构体类型的时候同时定义变量：  
```c
struct 结构体类型名{    //其中struct为关键字
	成员表;			//可以有多个成员
	成员函数;		//可以有多个函数，也可以没有
}结构体变量;			//可以同时定义多个结构体变量，用“，”隔开  
//例如：
struct student{
	char name;
	int chinese,math;
	int total;
}a[110]; 		//	同时定义了a数组变量
```
- （2）先定义结构体再定义结构体变量：  
```c
struct 结构体类型名{
	成员表;
	成员函数;
}；
结构体名 结构体变量表		//可以同时定义多个结构体变量
//例如：
struct student{
	char name;
	int chinese,math;
	int total;
};
student a[110];
```
:::tip 注意
在定义结构体变量时，结构体变量名与结构体名不能相同，在定义结构体时，系统对其不分配实际内存。只有定义结构体变量时，系统才为其分配内存。
:::
#### 5.1.2 结构体变量的特点
- （1）结构体变量可以整体操作，例如：
 ```c
swap(a[j],a[j+1]);
```
- （2）结构体变量的成员访问也很方便，清晰，例如：
:::code-group
```C
scanf("%s",&a[i].name);
```
```C++
cin>>a[i].name;
```
:::

- （3）结构体变量的初始化和数组的初始化类似，例如：
```c
student op={"yuanshen",60,80,100};
```
#### 5.1.3 成员调用
结构体变量与各个成员之间的引用形式一般为：
```c
	结构体变量名.成员名
```
对于上面定义的结构体变量，我们可以这样操作：
:::code-group
```C
scanf("%s",a[i].name);
a[i].total=a[i].chinese+a[i].math;
```
```C++
cin>>a[i].name;
a[i].total=a[i].chinese+a[i].math;
```
:::
实际上结构体成员的操作与该成员类型所具有的操作是一致的。  
成员运算符“$.$”在存取成员数值时使用，其优先性最高，有左结合性。在处理**包含结构体的结构体**时，可记作：
```c
strua.strub.membb;
```
这说明结构体变量srtua有结构体成员strub，结构体变量strub有成员membb。
#### 5.1.4 成员函数调用
结构体成员函数调用的一般形式为：
```c
	结构体变量名.成员函数;
```
结构体成员函数默认将结构体变量作为引用参数。  

### 5.2 结构体与指针
#### 5.2.1 结构体指针的定义与使用
当一个指针变量指向一个结构体变量时，称之为结构体指针变量。  
结构体指针变量的值是所指向的结构体变量的起始地址。通过结构体指针即可访问结构体变量——这与数组指针和函数指针的情况是相同的。  
结构体指针变量定义的一般形式：  
```c
结构体名 *结构体指针变量名
```
当然也可以在定义结构体的同时定义这个结构体指针变量。  
**例**
:::code-group
```c[写法1]
struct student{
	char name[20];
	char sex;
	float score;
}*p;
```
```c[写法2]
struct student{
	char name[20];
	char sex;
	float score;
};
student *p;
```
与前面讨论的各类指针变量相同，结构体指针变量也需要赋值后才能使用，赋值是把结构体变量的首地址赋予该变量，不能把结构体名赋予该指针变量。  
**例如：** 如果p是被定义为student类型的结构体变量，boy是被定义为student类型的结构体变量，则：`p=&boy`是正确的，而`p=&student`是错误的！  
引入结构体指针变量指向的结构体变量的成员的方法如下：   
- 指针名->成员名
- (*指针名).成员名

::: info 示例
(*p).score与p->score是等价的
:::

#### 5.2.2 自引用结构
在一个结构体内部包含一个类型为结构体本身的成员是否合法呢？
```c
struct stu{
	char name[20];
	int age,score;
	stu p;
};
```
**注意：像上面这种自引用是非法的！这类似于一种无穷递归。**    
但是像下面这种自引用是合法的：
```c
struct stu{
	char name[20];
	int age,score;
	stu *p;
};
```
这种声明和上面的不同之处在于现在的p是一个指针，而不是结构体。编译器在结构体的长度之前就已经知道指针的长度，所以这种类型的自引用当然是合法的。  
这种自引用是实现其他一些结构的基础。自引用在动态数据结构中有重要的应用，甚至可以说，自引用结构是C/C++实现动态数据结构的基石。包括动态的链表，堆，栈，树，无不是自引用的具体实现。

## 6.C语言课后作业题
### 6.1 数据类型、运算符与表达式
#### 6.1.1 计算平均值
**【问题描述】**   
从键盘输入三个整数，分别存入x,y,z三个整型变量中，计算并输出三个数的和以及平均值。  
**【输入形式】**   
从键盘输入三个整数，整数之间以空格隔开。  
**【输出形式】**   
在屏幕上分两行显示结果：  
第一行为三个数的和，整数形式输出；  
第二行为三个数的平均值，浮点数形式输出，小数点后保留两位小数。
::: details 答案
```c
#include <stdio.h>
int main(){
int x, y, z;
int sum;
double average;
scanf("%d%d%d", &x, &y, &z);
sum = x + y + z;
average = (double)sum / 3;
printf("%d\n", sum);
printf("%.2f", average);
return 0;
}
```
 :::
#### 6.1.2 求三角形面积
**【问题描述】**  
若已知三角形三个边的长度分别为a,b,c（并假设三个边长度的单位一致，在本编程题中忽略其单位），则可以利用公式:  
$$
S=\sqrt{s(s - a)(s - b)(s - c)}
$$
求得三角形的面积，其中：$s=\frac{(a+b+c)}{2}$。编程实现从控制台读入以整数表示的三个边的长度（假设输入的长度肯定可以形成三角形），然后利用上述公式计算面积并输出，结果小数点后保留3位有效数字。  
**【输入形式】**  
从控制台输入三个整数表示三角形三个边的长度，以空格分隔三个整数。  
**【输出形式】**  
向控制台输出求得的三角形的面积，小数点后保留三位有效数字。
::: details 答案
```c
#include <stdio.h>
#include <math.h>
int main(){
int a,b,c;
double s,area;
scanf("%d%d%d",&a,&b,&c);
s=(a+b+c)/2.0;
area=sqrt(s*(s-a)*(s-b)*(s-c));
printf("%.3f",area);
}
```
 :::
#### 6.1.3 摄氏华氏温度转换
**【问题描述】**  
假如用C表示摄氏温度，F表示华氏温度，则有：$F = C\times\frac{9}{5}+32$。输入一整数表示摄氏温度，根据该公式编程求对应的华氏温度，结果小数点后保留一位有效数字。   
**【输入形式】**  
从控制台读入一个整数，表示摄氏温度。   
**【输出形式】**   
向控制台输出转换后的华氏温度，结果小数点后保留一位有效数字。 
::: details 答案
```c
#include <stdio.h>
int main(){
int C;
float F;
scanf("%d",&C);
F=C*9.0/5.0+32.0; //注意浮点数运算！不要写成整数了 // [!code warning]
printf("%.1f",F);
return 0;
}
```
 :::
#### 6.1.4 前驱、后继字符
**【问题描述】**  
从键盘输入一个字符，求出它的前驱和后继字符（按照ASCII码值排序），并按照从小到大的顺序输出这三个字符和对应的ASCII值。  
**【输入形式】**  
从键盘输入一个字符  
**【输出形式】**  
按两行输出：  
第一行按照从小到大的顺序输出这三个字符，并以一个空格隔开；  
第二行按照从小到大的顺序输出三个字符对应的ASCII值，并以一个空格隔开。
::: details 答案
```c
#include <stdio.h>
int main(){
char ch;
scanf("%c", &ch);
printf("%c %c %c\n", ch-1, ch, ch+1);
printf("%d %d %d", ch-1, ch, ch+1);//这样可以直接输出ASCII码 // [!code warning]
return 0;
}
```
 :::

 ### 6.2 流程控制
#### 6.2.1    找最大最小整数
**【问题描述】**      
编写一个程序，用户输入若干整数，试找出其中的最大数和最小数。    
**【输入形式】**    
用户在第一行待输入数据个数，在第二行输入数据。     
**【输出形式】**     
程序在下一行输出数据的最大值和最小值    
::: details 答案
```c
#include <stdio.h>
int main(){
	int n, a[n + 5], i;
	scanf("%d", &n);
	for (i = 0; i < n; i++){
		scanf("%d", &a[i]);
	}
	int max = 0, min = 1000000;
	for (i = 0; i < n; i++){
		if (a[i] > max){
		max = a[i];
		}
		if (a[i] < min){
		min = a[i];
		}
	}
	printf("%d %d", max, min);
	return 0;
}
```
 :::

#### 6.2.2    工资
**【问题描述】**    
假设税前工资和税率如下（s代表税前工资，t代表税率）：    
s<1000  t=0%    
1000<=s<2000 t=10%    
2000<=s<3000 t=15%    
3000<=s<4000 t=20%    
4000<=s t=25%    
编写一程序，要求用户输入税前工资额，然后用switch语句计算税后工资额。    
**【输入形式】**    
从键盘输入税前工资s，可以是浮点数。    
**【输出形式】**    
输出税后工资额，保留小数后两位。  
::: details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    float s;
    scanf("%f", &s);
    int category;
    if (s < 1000){category = 0;}
    else if (s < 2000){category = 1;}
    else if (s < 3000){category = 2;}
    else if (s < 4000){category = 3;}
    else{category = 4;}
    float taxRate;
    switch (category){
    case 0:
        taxRate = 0;
        break;
    case 1:
        taxRate = 0.1;
        break;
    case 2:
        taxRate = 0.15;
        break;
    case 3:
        taxRate = 0.2;
        break;
    case 4:
        taxRate = 0.25;
        break;
    default:
        break;
    }
    float afterTaxSalary = s * (1 - taxRate);
    printf("%.2f\n", afterTaxSalary);
    return 0;
}
```
 :::

#### 6.2.3 求和
**【问题描述】**  
编写一个程序，求s=1+(1+2)+(1+2+3)+...+(1+2+3+...+n)。    
**【输入形式】**    
输入一个正整数n，根据求s公式计算s并输出。    
**【输出形式】**    
输出的为s的结果。   
::: details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int sum(n){
    return n * (n + 1) / 2;
}
int main(){
    int n, s = 0, i;
    scanf("%d", &n);
    for (i = 1; i <= n; i++){
        s += sum(i);
    }
    printf("%d", s);
    return 0;
}
```
 :::
 
 #### 6.2.4 简易计算器
 **【问题描述】**  
编程实现简易的计算器：读入两个整数运算数(data1和data2)及一个运算符(op)，计算表达式data1 op data2的值，其中op可以是+,-,$*$,/。  
 **【输入形式】**   
控制台输入运算数和运算符:    
1.首先输入以空格分隔的两个整数，分别是data1和data2；    
2.输入一个字符作为运算符op，op可以是'+'，'-'，'$*$'，'/'。    
输入时，data1、data2、op之间各留有一个空格。具体格式见样例输入。  
 **【输出形式】**   
控制台输出运算结果。作除法运算时，若能够整除，则输出为整数，否则输出结果小数点后应保留两位有效数字。   
::: details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    int data1, data2;
    char op;
    scanf("%d %d %c", &data1, &data2, &op);
    switch (op){
    case '+':
        printf("%d", data1 + data2);
        break;
    case '-':
        printf("%d", data1 - data2);
        break;
    case '*':
        printf("%d", data1 * data2);
        break;
    case '/':
        if (data1 % data2 == 0){
            printf("%d", data1 / data2);
        }
        else{
            printf("%.2f", (float)data1 / data2);
        }
        break;
    default:
        break;
    }
    return 0;
}
```
 :::

 #### 6.2.5 同构数
  **【问题描述】**  
具有下面性质的数a称为"同构数"：设b是a的平方，a与b的低若干位相同。例如，5是25的同构数,25是625的同构数.编程序满足如下要求:    
输入两个整数a,b (0<=a, b<=99),找出a、b之间全部的同构数。    
 **【输入形式】**  
控制台输入0-99之间的两个整数a和b.    
 **【输出形式】**   
控制台上按照由小到大的顺序输出所有同构数.每一个整数占一行.    
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int a, b, num, square;
    scanf("%d %d", &a, &b);
    for (num = a; num <= b; num++)
    {
        square = num * num;
        if (num < 10)
        {
            if (square % 10 == num)
            {
                printf("%d\n", num);
            }
        }
        else
        {
            if (square % 100 == num)
            {
                printf("%d\n", num);
            }
        }
    }
    return 0;
} 
```
:::

 #### 6.2.6 求水仙花数
 **【问题描述】**  
编写一个程序，输入一个正整数N(N大于等于100小于等于999)，求出100~N之间的所有水仙花数。所谓 的水仙花数是：如果一个三位数的个位数、十位数、百位数的立方和等于该数自身，就称这个数为水仙花数。    
 **【输入形式】**   
输入一个正整数N。    
 **【输出形式】**   
输出从100到N之间的所有水仙花数，每个数以回车结束。   
:::details 答案
```c
#include <stdio.h>
int main()
{
    int N, num, hundreds, tens, units;
    scanf("%d", &N);
    for (num = 100; num <= N; num++)
    {
        hundreds = num / 100;
        tens = (num % 100) / 10;
        units = num % 10;
        if (hundreds * hundreds * hundreds + tens * tens * tens + units * units * units == num)
        {
            printf("%d\n", num);
        }
    }
    return 0;
}
```
:::

 #### 6.2.7 整数求和
**【问题描述】**    
输入2个正整数a和n，求a+aa+aaa+...+aa...a（n个a）。不考虑整数溢出情况。  
**【输入形式】**   
从标准输入中读入两个以空格分隔的正整数（大于等于1，小于等于9）。  
**【输出形式】**   
在标准输出中输出整数相加式及结果和。运算符（+, =）与整数之间用一个空格分隔。   
:::details 答案
```c
#include <stdio.h>
int main()
{
    int a, n, i, temp, result = 0;
    scanf("%d %d", &a, &n);
    printf("%d", a);
    temp = a;
    result = a;
    for (i = 1; i < n; i++)
    {
        temp = temp * 10 + a;
        printf(" + %d", temp);
        result += temp;
    }
    printf(" = %d", result);
    return 0;
}
```
:::


 #### 6.2.8 求A,B
 **【问题描述】**   
输入三位数字N，求两位数AB（其中个位数字为B，十位数字为A，且有0 < A < B &le;9）。使得下列等式成立：    
AB x BA = N    
其中BA是把AB中个、十位数字交换所得的两位数。     
编写程序，接收控制台输入的三位整数N，求解A，B并输出。    
如果没有解则输出"No Answer"。    
 **【输入形式】**     
从键盘输入整数N。     
 **【输出形式】**   
输出只有一行，包含两个数字A和B。输出时两个数字紧密输出，不使用其它字符进行分隔。   
:::details 答案
```c
#include <stdio.h>
int main()
{
    int N, A, B, num1, num2, found = 0;
    scanf("%d", &N);
    for (A = 1; A < 9; A++)
    {
        for (B = A + 1; B < 10; B++)
        {
            num1 = 10 * A + B;
            num2 = 10 * B + A;
            if (num1 * num2 == N)
            {
                printf("%d%d", A, B);
                found = 1;
                break;
            }
        }
        if (found)
        {
            break;
        }
    }
    if (!found)
    {
        printf("No Answer");
    }
    return 0;
}
```
:::


 #### 6.2.9 最大公约数和最小公倍数
 **【问题描述】**   
输入两个正整数a和b（0<a，b<1000000），求出其最大公约数和最小公倍数并输出。    
**【输入文件】**  
从标准输入读取一行，是两个整数a和b，以空格分隔。   
**【输出文件】**   
向标准输出打印以空格分隔的两个整数，分别是a、b的最大公约数和最小公倍数。在输出末尾要有一个回车符。   
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
int lcm(int a, int b)
{
    return a * b / gcd(a, b);
}
int main()
{
    int x, y;
    scanf("%d %d", &x, &y);
    printf("%d %d\n", gcd(x, y), lcm(x, y));
    return 0;
}
```
:::
#### 6.2.10 比较两组整数（新）
**【问题描述】**   
比较两组整数是否有相同的元素，每组整数个数不超过100。若有相同的元素，则按照由大到小的顺序输出相同的元素（重复出现的元素只输出一个）。如果没有相同元素，打印字符串：No Answer。   
**【输入形式】**   
首先从标准输入（键盘）输入第一组整数的个数，再输入第一组整数，以一个空格分割；然后输入第二组整数的个数，再输入第二组整数，以一个空格分割。  
**【输出形式】**   
按照由大到小的顺序向标准输出（显示器）输出两组整数中相同的元素，以一个空格分隔；如果没有相同元素，则打印"No Answer"。   
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    int i, j;
    for (i = 0; i < n-1; i++) {
        for (j = 0; j < n-i-1; j++) {
            if (arr[j] < arr[j+1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
int main() {
    int n1, n2, arr1[MAX_SIZE], arr2[MAX_SIZE];
    int i, j, count = 0, common[MAX_SIZE];
    // 读取第一个数组
    scanf("%d", &n1);
    for (i = 0; i < n1; i++) {
        scanf("%d", &arr1[i]);
    }
    // 读取第二个数组
    scanf("%d", &n2);
    for (i = 0; i < n2; i++) {
        scanf("%d", &arr2[i]);
    }
    // 找出两个数组中的共同元素，并去重
    for (i = 0; i < n1; i++) {
        for (j = 0; j < n2; j++) {
            int isDuplicate = 0;
            if (arr1[i] == arr2[j]) {
                int k;
                for (k = 0; k < count; k++) {
                    if (common[k] == arr1[i]) {
                        isDuplicate = 1;
                        break;
                    }
                }
                if (!isDuplicate) {
                    common[count++] = arr1[i];
                }
            }
        }
    }
    // 如果没有共同元素，输出 "No Answer"
    if (count == 0) {
        printf("No Answer");
    } else {
        // 使用冒泡排序对共同元素进行降序排序
        bubbleSort(common, count);
        // 输出排序后的共同元素
        for (i = 0; i < count; i++) {
            if (i != 0) {
                printf(" ");
            }
            printf("%d", common[i]);
        }
    }
    return 0;
}
```
:::
### 6.3 数组
#### 6.3.1 在数组中插入新元素
**【问题描述】**  
现有一个数组{1,4,6,9,13,16,19,28,40,100}，用户输入一个数字，要求按照原数组的排序方式将用户输入的数字插入到数组中并输出新数组。  
**【输入形式】**  
输入一个整数   
**【输出形式】**  
输出新的排序完成的数组  
:::details 答案
```c
#include <stdio.h>
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main() {
    int arr[11] = {1, 4, 6, 9, 13, 16, 19, 28, 40, 100};
    int num;
    // 输入要插入的数字
    scanf("%d", &num);
    // 将输入的数字放入数组的最后一个位置
    arr[10] = num;
    // 使用冒泡排序对数组进行升序排序
    bubbleSort(arr, 11);
    // 输出排序后的数组
    for (int i = 0; i < 11; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
```
:::
 
 #### 6.3.2   字符串中字符排序
 **【问题描述】**   
编写一个程序，从键盘接收一个字符串，然后按照字符顺序从小到大进行排序，并删除重复的字符。     
**【输入形式】**    
用户在第一行输入一个字符串。    
**【输出形式】**   
程序按照字符(ASCII)顺序从小到大排序字符串，并删除重复的字符进行输出。   
:::details 答案
```c
#include <stdio.h>
#include <string.h>
// 冒泡排序函数
void bubbleSort(char arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换字符
                char temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main() {
    char str[1000]; // 假设输入的字符串长度不超过 1000
    scanf("%s", str);
    int len = strlen(str);
    // 使用冒泡排序对字符串进行排序
    bubbleSort(str, len);
    // 去重并生成结果字符串
    char result[1000];
    int resultIndex = 0;
    for (int i = 0; i < len; i++) {
        if (i == 0 || str[i] != str[i - 1]) {
            result[resultIndex++] = str[i];
        }
    }
    result[resultIndex] = '\0'; // 添加字符串结束符
    // 输出结果
    printf("%s\n", result);
    return 0;
}
```
:::

 #### 6.3.3   判断两个数据集是否相同
 **【问题描述】**   
从标准输入中读入两个整数集，整数集中数据无序，且可能有重复数据。当两个数据集中数据完全相同（数据相同，数据若重复，重复个数也相同，顺序不一定相同），则两个数据集相同。编写一程序判断输入的两数据集是否相同：用1表示相同，用0表示不同。   
**【输入形式】**   
先输入第一组整数集的个数（大于等于1，小于等于20），然后输入第一组整数（以一个空格分隔）；再输入第二组整数集的个数（大于等于1，小于等于20），并输入第二组整数（以一个空格分隔）。   
**【输出形式】**   
若两数据集相同，则输出1，否则输出0，然后按照从小到大的顺序分行输出第一个数据集中的数据及重复个数（以一个空格分隔数据和重复个数）。   
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
// 统计数组中每个元素的重复次数
void countDuplicates(int arr[], int n, int counts[]) {
    for (int i = 0; i < n; i++) {
        counts[i] = 1;
    }
    for (int i = 0; i < n; i++) {
        if (arr[i] != -1) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] == arr[j]) {
                    counts[i]++;
                    arr[j] = -1; // 标记为已处理
                }
            }
        }
    }
}
// 比较两个数组是否相同
int compareArrays(int arr1[], int counts1[], int n1, int arr2[], int counts2[], int n2) {
    if (n1 != n2) {
        return 0;
    }
    for (int i = 0; i < n1; i++) {
        if (arr1[i] != arr2[i] || counts1[i] != counts2[i]) {
            return 0;
        }
    }
    return 1;
}
int main() {
    int n1, n2;
    int arr1[20], arr2[20];
    int counts1[20], counts2[20];
    // 读取第一个数组
    scanf("%d", &n1);
    for (int i = 0; i < n1; i++) {
        scanf("%d", &arr1[i]);
    }
    // 读取第二个数组
    scanf("%d", &n2);
    for (int i = 0; i < n2; i++) {
        scanf("%d", &arr2[i]);
    }
    // 对两个数组进行排序
    bubbleSort(arr1, n1);
    bubbleSort(arr2, n2);
    // 统计每个数组中元素的重复次数
    countDuplicates(arr1, n1, counts1);
    countDuplicates(arr2, n2, counts2);
    // 比较两个数组是否相同
    int result = compareArrays(arr1, counts1, n1, arr2, counts2, n2);
    printf("%d\n", result);
    // 输出第一个数组的元素及其重复次数
    for (int i = 0; i < n1; i++) {
        if (arr1[i] != -1) {
            printf("%d %d\n", arr1[i], counts1[i]);
        }
    }
    return 0;
}
```
:::

 #### 6.3.4   旋转矩阵
 **【问题描述】**   
从标准输入中输入两个N（N<=9）阶矩阵，判断第二个矩阵是否是第一个矩阵的旋转矩阵，并输出旋转角度，若不是则输出-1。一个矩阵若是另一个矩阵通过顺时针旋转0度、90度、180度或270度得到，则该矩阵是旋转矩阵。   
**【输入形式】**   
从标准输入读取矩阵。   
第一行只有一个整数N，代表两个矩阵的阶数。   
然后在后续N行上输入第一个矩阵，每行有N个以若干空格分隔的整数，代表该矩阵在该行上的所有元素。   
输入第一个矩阵后，再在后续的N行上输入第二个矩阵，每行有N个以若干空格分隔的整数，代表该矩阵在该行上的所有元素。   
**【输出形式】**    
若第二个矩阵是第一个矩阵的旋转矩阵，则输出旋转角度（取值为0、90、180或270），若不是则输出－1。    
:::details 答案
```c
#include <stdio.h>
int isEqual(int matrix1[9][9], int matrix2[9][9], int n);
void rotate90(int matrix[9][9], int n);
void rotate180(int matrix[9][9], int n);
void rotate270(int matrix[9][9], int n);
int main()
{
    int n, i, j;
    int matrix1[9][9], matrix2[9][9];
    scanf("%d", &n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &matrix1[i][j]);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &matrix2[i][j]);
    if (isEqual(matrix1, matrix2, n))
    {
        printf("0\n");
        return 0;
    }
    int tempMatrix[9][9];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            tempMatrix[i][j] = matrix1[i][j];
    rotate90(tempMatrix, n);
    if (isEqual(tempMatrix, matrix2, n))
    {
        printf("90\n");
        return 0;
    }
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            tempMatrix[i][j] = matrix1[i][j];
    rotate180(tempMatrix, n);
    if (isEqual(tempMatrix, matrix2, n))
    {
        printf("180\n");
        return 0;
    }
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            tempMatrix[i][j] = matrix1[i][j];
    rotate270(tempMatrix, n);
    if (isEqual(tempMatrix, matrix2, n))
    {
        printf("270\n");
        return 0;
    }
    printf("-1\n");
    return 0;
}
int isEqual(int matrix1[9][9], int matrix2[9][9], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            if (matrix1[i][j] != matrix2[i][j])
                return 0;
    return 1;
}
void rotate90(int matrix[9][9], int n)
{
    int temp[9][9], i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            temp[j][n - 1 - i] = matrix[i][j];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            matrix[i][j] = temp[i][j];
}
void rotate180(int matrix[9][9], int n)
{
    int temp[9][9], i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            temp[n - 1 - i][n - 1 - j] = matrix[i][j];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            matrix[i][j] = temp[i][j];
}
void rotate270(int matrix[9][9], int n)
{
    int temp[9][9], i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            temp[n - 1 - j][i] = matrix[i][j];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            matrix[i][j] = temp[i][j];
}
```
:::

 #### 6.3.5     求两组整数的并集
 **【问题描述】**  
从标准输入中输入两组整数(每组不超过20个整数，每组整数中元素不重复)，合并两组整数，重复的整数只出现一次，并按从大到小顺序排序输出（即两组整数集的"并集"）。  
**【输入形式】**  
首先输入第一组整数的个数，然后在下一行输入第一组整数，以一个空格分隔各个整数；再在新的一行上输入第二组整数的个数，然后在下一行输入第二组整数，以一个空格分隔。  
**【输出形式】**   
按从大到小顺序排序输出合并后的整数集（以一个空格分隔各个整数，最后一个整数后的空格可有可无）。   
:::details 答案
```c
#include <stdio.h>
// 冒泡排序函数（从大到小排序）
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] < arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main() {
    int n1, n2;
    int arr1[20], arr2[20], result[40]; // 最多20个元素，合并后最多40个
    int count = 0; // 记录合并后数组的长度
    // 读取第一个数组
    scanf("%d", &n1);
    for (int i = 0; i < n1; i++) {
        scanf("%d", &arr1[i]);
    }
    // 读取第二个数组
    scanf("%d", &n2);
    for (int i = 0; i < n2; i++) {
        scanf("%d", &arr2[i]);
    }
    // 将第一个数组的元素加入结果数组
    for (int i = 0; i < n1; i++) {
        int isDuplicate = 0;
        for (int j = 0; j < count; j++) {
            if (arr1[i] == result[j]) {
                isDuplicate = 1;
                break;
            }
        }
        if (!isDuplicate) {
            result[count++] = arr1[i];
        }
    }
    // 将第二个数组的元素加入结果数组
    for (int i = 0; i < n2; i++) {
        int isDuplicate = 0;
        for (int j = 0; j < count; j++) {
            if (arr2[i] == result[j]) {
                isDuplicate = 1;
                break;
            }
        }
        if (!isDuplicate) {
            result[count++] = arr2[i];
        }
    }
    // 对结果数组进行从大到小排序
    bubbleSort(result, count);
    // 输出结果
    for (int i = 0; i < count; i++) {
        printf("%d", result[i]);
        if (i < count - 1) {
            printf(" ");
        }
    }
    printf("\n");
    return 0;
}
```
:::


### 6.4 函数、指针、字符串
#### 6.4.1 素数判断
**【问题描述】**     
编写一个函数isprime(n).判断整数n是否为素数.编写程序使用此函数,当输入一个整数时,对它进行判断,当为素数时,输出1.否则,输出0.    
**【输入形式】**    
控制台输入一个整数.     
**【输出形式】**    
控制台输出判断结果0或者1.   
:::details 答案
```c
#include <stdio.h>
int is_prime(int n){
    if (n <= 1){
        return 1;
    }
    else if (n == 2){
        return 0;
    }
    else{
        int i;
        for (i = 2; i * i <= n; i++){
            if (n % i == 0){
                return 1;
            }
        }
        return 0;
    }
}
int main(){
    int n;
    scanf("%d", &n);
    if (is_prime(n){
        printf("0");
    }
    else{
        printf("1");
    }
    return 0;
}
```
:::

#### 6.4.2 n的阶乘
**【问题描述】**   
编写函数fac(n),用递归法求出n的阶乘.在程序中使用此函数,将输入的整数n的阶乘求出并输出到控制台.     
**【输入形式】**   
控制台输入整数n     
**【输出形式】**      
控制台输出n!    
:::details 答案
```c
#include <stdio.h>
int fac(int n){
    if (n == 0){
        return 1;
    }
    else{
        return n * fac(n - 1);
    }
}
int main(){
    int n;
    scanf("%d", &n);
    printf("%d", fac(n));
    return 0;
}
```
:::

#### 6.4.3 回文数A
**【问题描述】**   
所谓"回文数"是指具有如下性质的整数：一个整数，当它的各位数字逆序排列，形成的整数与原整数相同，这样的数称为回文数。例如，素数11，373，其各位数字对换位置后仍然为11，373，因此这两个整数均为回文数。编写函数int loop(int x)，判断一个整数是否为回文数，如果x是回文数则返回1，否则返回0。编写程序loop.c，接收控制台输入的两个整数a，b。调用loop函数输出a到b之间（包括a和b）的所有为偶数的回文数。    
**【输入形式】**   
控制台输入两个整数a和b（必有a<b），以空格分隔。    
**【输出形式】**    
输出有若干行，每行有一个a和b之间的回文数。输出各行上的数字不重复，且从小至大依次按序输出。  
:::details 答案
```c
#include <stdio.h>
int loop(int n) {
    int original = n;
    int reversed = 0;
    while (n > 0) {
        reversed = reversed * 10 + n % 10;
        n /= 10;
    }
    return (original == reversed && original % 2 == 0);
}
int main() {
    int min, max;
    scanf("%d %d", &min, &max);
    int i;
    for (i = min; i <= max; i++) {
        if (loop(i)) {
            printf("%d\n", i);
        }
    }
    return 0;
}
```
:::
#### 6.4.4   判断两个数组是否包含相同元素
**【问题描述】**     
编写一个函数 int same_set(int a[],int b[],int len)，    
该函数检查相等长度的两个数组是否包含相同的元素,若包含相同的元素,   
则返回1,否则返回0,其中参数len是数组a与与数组b的元素个数。   
不考虑元素的顺序，如果元素重复，重复次数也相同。在main函数中读入两个整数数组,测试该函数。   
**【输入形式】**    
从键盘输入两个数组，第一行输入数组元素个数，第二行输入第一个数组的各个值，   
第三行输入第二个数组的各个值。  
**【输出形式】**      
如果两个数组包含的元素相同，打印1，否则，打印0。 
:::details 答案
```c
#include <stdio.h>
// 冒泡排序函数
void bubble_sort(int arr[], int len) {
    int i, j, temp;
    for (i = 0; i < len - 1; i++) {
        for (j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
// 判断两个数组是否相同
int same_set(int a[], int b[], int len) {
    bubble_sort(a, len);
    bubble_sort(b, len);
    int i;
    for (i = 0; i < len; i++) {
        if (a[i] != b[i]) {
            return 0;
        }
    }
    return 1;
}
int main() {
    int len, i;
    int a[100], b[100]; // 假设数组的最大长度为 100
    // 读取数组长度
    scanf("%d", &len);
    // 读取数组a
    for (i = 0; i < len; i++) {
        scanf("%d", &a[i]);
    }
    // 读取数组b
    for (i = 0; i < len; i++) {
        scanf("%d", &b[i]);
    }
    // 判断两个数组是否相同
    int result = same_set(a, b, len);
    printf("%d", result);
    return 0;
}
```
:::

#### 6.4.5 整数合并
**【问题描述】**     
编写一函数int comb(int a,int b)，将两个两位数的正整数a、b合并形成一个整数并返回。合并的方式是：将a的十位和个位数依次放在结果的十位和千位上， b的十位和个位数依次放在结果的个位和百位上。例如，当a＝45，b=12。调用该函数后，返回5241。要求在main函数中调用该函数进行验证：从键盘输入两个整数，然后调用该函数进行合并，并输出合并后的结果。       
**【输入形式】**    
输入两个两位数的正整数，以空格隔开。 
**【输出形式】**    
输出合并后的正整数。  
:::details 答案
```c
#include <stdio.h>
int loop(int n) {
    int original = n;
    int reversed = 0;
    while (n > 0) {
        reversed = reversed * 10 + n % 10;
        n /= 10;
    }
    return (original == reversed && original % 2 == 0);
}
int main() {
    int min, max;
    scanf("%d %d", &min, &max);
    int i;
    for (i = min; i <= max; i++) {
        if (loop(i)) {
            printf("%d\n", i);
        }
    }
    return 0;
}
```
:::
#### 6.4.6   删除子串
**【问题描述】**   
编写一个程序，当在一个字符串中出现子串时就删除它。    
**【输入形式】**    
用户在第一行输入一个字符串，用户在第二行输入一个子串。    
**【输出形式】**   
程序在下一行输出删除其中所有子串后的字符串。如果字符串不包含子串则输出原字符串本身。  
:::details 答案
```c
#include <stdio.h>
#include <string.h>
int main()
{
    char str[1000], sub[100];
    fgets(str, sizeof(str), stdin);
    fgets(sub, sizeof(sub), stdin);
    str[strcspn(str, "\n")] = '\0';
    sub[strcspn(sub, "\n")] = '\0';
    char *src = str;
    char *dst = str;
    while (*src)
    {
        if (strncmp(src, sub, strlen(sub)) == 0)
        {
            src += strlen(sub);
        }
        else
        {
            *dst++ = *src++;
        }
    }
    *dst = '\0';
    printf("%s", str);
    return 0;
}
```
:::

#### 6.4.7   求一个字符串的所有子字符串
**【问题描述】**   
从控制台读入一个字符串（长度不超过10），向控制台输出其所有子字符串（包括原字符串本身）。  
**【输入形式】**   
从控制台输入一个字符串，字符串中不含空格。  
**【输出形式】**   
向控制台输出所有子字符串，每行输出一个，先输出长度短的子字符串，长度相同时以在原字符串中出现的先后顺序输出。   
:::details 答案
```c
#include <stdio.h>
#include <string.h>
int main() {
    char s[11];
    scanf("%s", s);
    int len = strlen(s);
    int sub_len, start, i;
    for (sub_len = 1; sub_len <= len; sub_len++) {
        for (start = 0; start <= len - sub_len; start++) {
            for (i = 0; i < sub_len; i++) {
                printf("%c", s[start + i]);
            }
            printf("\n");
        }
    }
    return 0;
}
```
:::

#### 6.4.8 合并字符串
**【问题描述】**     
编写一个函数void str_bin(char str1[ ], char str2[ ])， str1、str2是两个有序字符串（其中字符按ASCII码从小到大排序），将str2合并到字符串str1中，要求合并后的字符串仍是有序的，允许字符重复。在main函数中测试该函数：从键盘输入两个有序字符串，然后调用该函数，最后输出合并后的结果。    
**【输入形式】**     
分行从键盘输入两个有序字符串（不超过100个字符）    
**【输出形式】**     
输出合并后的有序字符串    
:::details 答案
```c
#include <stdio.h>
#include <string.h>
void str_bin(char str1[], char str2[]){
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    int i = 0, j = 0, k = 0;
    char temp[200] = {0}; // 临时数组存合并结果
    while (i < len1 && j < len2){
        if (str1[i] < str2[j]){
            temp[k++] = str1[i++];
        }
        else{
            temp[k++] = str2[j++];
        }
    }
    while (i < len1){
        temp[k++] = str1[i++];
    }
    while (j < len2){
        temp[k++] = str2[j++];
    }
    temp[k] = '\0';
    strcpy(str1, temp); // 把结果复制回str1
}
int main()
{
    char str1[101], str2[101];
    scanf("%s", str1);
    scanf("%s", str2);
    str_bin(str1, str2);
    printf("%s\n", str1);
    return 0;
}
```
:::

## C++
C++是一门面向对象的语言，先从面向对象开始介绍。
## 1.面向对象
### 1.1  面向对象基本概念
#### 1.1.1 类和对象
-   **类（class）定义**：类是一个模板，类似于结构体。用于创建对象。类中包含成员数据（属性）和成员函数（方法）。
- **对象（object）定义**：对象是类的实例化，通过对象可以访问类的成员。
    
 **示例-定义一个简单的类**：
```C++
class student {    //这个大括号中的叫类定义
    string name; // 学生的名字
    int age;     // 学生的年龄
};
int main(){
	student stu1;//创建对象
	stu1.name = “Alice”;//设置成员变量
	stu1.age = 25;
	return 0;
}
```
类名为student，类里的两个内容：年龄与名字叫做类的成员数据，或者叫属性。类比`int a=10`，10即为$a$的属性。stu1即为student类的一个对象，通过` . `操作符访问类的成员
#### 1.1.2 访问修饰符
C++中有三种访问修饰符，用于控制成员的访问权限。
- **public：** 成员可以被类外部访问。
- **private：** 成员只能在类内部访问（默认情况下，类的成员是私有的）。
- **protected：** 类似于private，但在继承（后文会提到）可以被子类访问。

**示例-使用访问修饰符**
```C++
class Person{
private:
	string name; //私有成员
	int age;
public:
	void setName(string n){ //公有函数，用于设置私有成员
		name = n；
	}
	void setAge(int a){
		if(a>=0) age = a;}
	void introduce(){
		cout<<“My name is ”<<name<<“ and I am “<<age<<“ years old.’<<endl;
	}
};
int main(){
	Person person1;
	//person1.name = “Alice”; //错误！！ name是私有成员，无法直接访问// [!code error]
	person1.setName(“Alice”);
	person1.setAge(25);
	person1.introduce();
	return 0;
}
```

### 1.2 封装
封装是将数据和操作数据的函数绑定在一起，并通过访问控制数据不被随意修改的一种机制。     
**封装的作用：**      
- 隐藏实现细节，防止外部直接修改数据。  
- 提供接口（如set和get函数）来安全地访问和修改数据。
#### 1.2.1 构造函数
在创建对象时自动调用，用于初始化对象。C++中有多种构造函数，用于不同的初始化场景：
- 默认构造函数：无参数，对象创建时调用。
- 带参构造函数：带参数，用于初始化成员。
- 拷贝构造函数：用已有对象初始化新对象。
- 移动构造函数（C++11）：转移资产所有权，提高效率。 

**示例-多种构造函数**
```C++
class Person{
private:
	string name;
	int* agrPtr; //动态分配内存
public:
	//默认构造函数		
	Person():name(“Unknown”),agePtr(new int(0)){
		cout <<“Default constructor”<<endl;
	}
	//带参构造函数
	Person(string n,int a):name(n),age(new int(a)){
		cout<<“Parameterized constructor”<<endl;
	}
	//拷贝构造函数
	Person(constant Person& other):name(other,name),agePtr(new int(*other.agePtr)){
		cout<<“Copy constuctor”<<endl;
	}
	//移动构造函数：使用不多，略
	//析构函数
	～Person(){
		delete agePtr; //释放动态内存
		cout<<“Destructor”<<endl;
	}
	void introduce(){
		cout<<“Name: ”<<name<<“,Age: “<<*agePtr<<endl;
	}
};
int main(){
	Person p1;//默认
	Person p2(“Alice”,25); //带参
	Person p3 = p2; //拷贝
	p3.introduce();
	return 0;
```
:::tip 补充
• 以下3种情况都要调用复制构造函数：     
① 当利用类的已有对象来初始化另一个新对象时，系统将自动调用复制构造函数.     
② 如果函数的形参是类对象，则在进行函数调用时(将实参传递给形参时)，将自动调用复制构造函数.      
③ 需要注意的是，如果函数的形参是类对象的指针或对象引用，则在函数调用时并不调用复制构造函数.       
④ 如果函数的返回值是类对象，则在执行返回语句时将自动调用复制构造函数(返回类指针和引用时不调用复制构造函数).      
:::
**浅拷贝与深拷贝**    
• 浅拷贝：默认的复制构造函数执行的是浅拷贝，它会逐个复制对象的成员变量。对于基本数据类型的成员变量，浅拷贝是合适的。但对于指针类型的成员变量，浅拷贝只是复制了指针的值，使得两个对象的指针指向同一块内存空间。这可能导致在对象销毁时，同一块内存被释放两次，引发错误。
• 深拷贝：为了解决浅拷贝的问题，需要自定义复制构造函数来实现深拷贝。在深拷贝中，对于指针类型的成员变量，会在堆上重新分配一块内存空间，并将源对象中指针所指向的内容复制到新的内存空间中。这样，两个对象的指针就指向不同的内存空间，相互独立，避免了内存释放的问题。

#### 1.2.2 析构函数
在对象销毁时自动调用，用于清理资源。   
**示例-构造函数和析构函数** 
```C++
class Person {
private:
    string name;
    int age;
public:
    // 构造函数
    Person(string n, int a) {
        name = n;
        age = a;
        cout << "Person object created!" << endl;
    }
    // 析构函数
    ~Person() {
        cout << "Person object destroyed!" << endl;
    }
    void introduce() {
        cout << "My name is " << name << " and I am " << age << " years old." << endl;
    }
};
int main() {
    Person person1("Alice", 25);  // 调用构造函数
    person1.introduce();
    return 0;  // person1 超出作用域，自动调用析构函数
}
```
---
### 1.3 继承
继承允许一个类（子类）继承另一个类（基类）的属性和方法，从而实现代码复用。
#### 1.3.1 基本语法
```C++
class DerivedClass : public BaseClass{
	//子类内容
};
```
#### 1.3.2 单继承
```C++
class Person {
protected:  // protected 允许子类访问
    string name;
    int age;
public:
    Person(string n, int a) : name(n), age(a) {}
    void introduce() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};
class Student : public Person {  // Student 继承 Person
private:
    int studentID;
public:
    Student(string n, int a, int id) : Person(n, a), studentID(id) {}
    void showStudent() {
        introduce();  // 调用基类的函数
        cout << "Student ID: " << studentID << endl;
    }
};
int main() {
    Student student("Bob", 20, 12345);
    student.showStudent();

    return 0;
}
```
- Student类继承了Person类的name和age，并添加了自己的studentID。
- ：Person（n，a）是初始化列表，用于调用基类的构造函数。

### 1.4 多态
多胎允许使用基类指针或引用调用子类的方法。主要通过**虚函数**实现。
#### 1.4.1 虚函数
在基类中将函数声明为virtual，子类可以重写（override）它。   
**示例-多态**  
```C++
class Person {
protected:
    string name;
public:
    Person(string n) : name(n) {}
    virtual void speak() {  // 虚函数
        cout << "I am a person named " << name << endl;
    }
    virtual ~Person() {}  // 虚析构函数，确保子类析构函数被调用
};
class Student : public Person {
public:
    Student(string n) : Person(n) {}
    void speak() override {  // 重写基类的虚函数
        cout << "I am a student named " << name << endl;
    }
};
int main() {
    Person* ptr;
    Student student("Charlie");
    ptr = &student;  // 基类指针指向子类对象
    ptr->speak();    // 调用子类的 speak()
    return 0;
}
```
:::tip
 没有virtual，会调用基类的speak（），这叫静态绑定；有了virtual，实现动态绑定。
:::



### 1.5 其他重要概念
#### 1.5.1 抽象类和纯虚函数
- 纯虚函数：`virtual void func()=0;`，包含纯虚函数的类是抽象类，不能实例化。
- 抽象类用于定义借口，子类必须实现纯虚函数。

**示例-抽象类**
```C++
class Shape {
public:
    virtual void draw() = 0;  // 纯虚函数
};
class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing a circle" << endl;
    }
};
```
#### 1.5.2 重载与重写
- 重载：在同一作用域内，函数名相同但参数不同。
- 重写：子类重新定义基类的虚函数。
### 1.6 常成员函数const
#### 1.6.1 const
- 只读取属性而不修改属性，即为常成员函数  

**示例-const成员**  
```C++
class student{
public:
	int age;
	string name;
	bool set(int i);//这个就是成员函数的声明，又叫方法
	bool read() const;//后面加了const，表示这个函数只读不写
}
bool student :: read() const{
	cout<<age<<endl;
	cout<<name<<endl;
	return true;}
student aa;
aa.read()
```
实际上可以不使用const，普通方法也可以读数据，加const只是安全起见，防止意外修改数据。  
#### 1.6.2 mutable
mutable成员变量让变量即便是在const函数中也能修改。  
**示例-mutable成员变量**   
```C++
class Person{
private:
	string name;
	mutable int accessCount;
public:
	Person(string n):name(n),accessCount(0){}
	string getName() const{
		accessCount++;
		return name;
	}
};
```
### 1.7 静态成员static
- 静态成员数据：一个类可创建多个对象，int a;int b;int c;int d;student类可以不停新建各种对象
- 需要一个变量cnt=4来表示程序已经创建了4个对象，cnt这个数，与student类有关，但又不属于aa bb这些中任意一个对象。这种**描述全局，又与某个对象属性无关的**，叫做**静态成员数据**。
- 读取静态成员数据的方法叫静态成员函数
- 在类定义中加入静态成员数据，静态成员函数。
```C++
class student{
public:
	int age;
	string name;
	student(); //构造函数
	static int cnt;//static表示静态成员数据，统计有多少个对象被创建。
	static int count();//static表示静态成员数据，返回有多少个对象。
}
int student::cnt=0;
student::student(){
	age = 20;
	name = "张三";
	cnt++; //每次创建一个对象。cnt+1
}
int student ::count() //静态成员函数的定义！！注意！这里不写static了。
{
	return cnt; //返回静态成员数据，统计有多少个对象
}
// 使用静态成员函数；
student aa;
student bb;
aa.count();//调用静态成员函数，返回2
bb.count();//还是返回2，静态成员不依赖于某个对象
student::count();//返回静态成员数据2
```

### 1.8 多态底层机制
多态的核心是**动态绑定**，通过虚函数表实现。
#### 1.8.1 虚函数表
每个包含虚函数的类都有一个虚函数表，存储虚函数的地址。对象中有一个指向虚函数表的指针（vptr）。运行时根据vptr调用正确的函数。  
```C++
#include <iostream>  
using namespace std;  
class Base {  
public:  
	virtual void func() { cout << "Base func" << endl; }  
};  
class Derived : public Base {  
public:  
	void func() override { cout << "Derived func" << endl; }  
};  
int main() {  
	Base* ptr = new Derived();  
	ptr->func(); // 输出 "Derived func"  
	delete ptr;  
	return 0;  
}
```
#### 1.8.2 虚析构函数
- 如果基类析构函数不是虚函数，删除基类指针时不会调用子类析构函数。导致资源泄露。

```C++
class Base {  
public:  
	virtual ~Base() { cout << "Base destructor" << endl; }  
};  
class Derived : public Base {  
public:  
	~Derived() { cout << "Derived destructor" << endl; }  
};  
int main() {  
	Base* ptr = new Derived();  
	delete ptr; // 正确调用 Derived 和 Base 的析构函数  
	return 0;  
}
```
### 1.9 面向对象课后习题
#### 1.9.1 类与对象
##### 1.设计并完成Complex类
【问题描述】
设计并完成Complex类，进行复数的四则运算。在主程序中测试这个类的函数。不要修改main函数。
```c++
#include <iostream>
using namespace std;
class Complex {
public:
	// 无参数构造函数
	// 有参构造函数
	// 实现以下复数运算的成员函数
	Complex add(Complex& other);
	Complex subtract(Complex& other);
	Complex multiply(Complex& other);
	Complex divide(Complex& other); //注意除0错误，输出提示，返回(0,0).
	// show函数已实现，输出复数 -5+3i，4-i 形式
	void show() {
	if (imag >= 0) cout << real << "+" << imag << "i"<<endl;
	else cout << real << "-" << -imag << "i"<<endl;
	}
private:
	double real; // 复数实部
	double imag; // 复数虚部
};
int main() { // 测试Complex类
	Complex c1(3, 4); // 创建复数 3+4i
	Complex c2(1, -2); // 创建复数 1-2i
	Complex result; // 创建复数 0-0i
	result = c1.add(c2); // 加法
	result.show();
	result = c1.subtract(c2);// 减法
	result.show();
	result = c1.multiply(c2);// 乘法
	result.show();
	result = c1.divide(c2);// 除法
	result.show();
}
```
:::details 题解
```C++
#include <iostream>
using namespace std;
class Complex {
public:
    // 无参数构造函数 // [!code focus]
    Complex(){};// [!code focus]
    // 有参构造函数 // [!code focus]
    Complex(double r, double i) {// [!code focus]
        real = r;// [!code focus]
        imag = i;// [!code focus]
    }// [!code focus]
    // 实现以下复数运算的成员函数
    Complex add(Complex& other);
    Complex subtract(Complex& other);
    Complex multiply(Complex& other);
    Complex divide(Complex& other); //注意除0错误，输出提示，返回(0,0).
// show函数已实现，输出复数 -5+3i，4-i 形式
    void show() {
    if (imag >= 0) cout << real << "+" << imag << "i"<<endl;
    else cout << real << "-" << -imag << "i"<<endl; 
    }
private:
    double real;      // 复数实部
    double imag;      // 复数虚部
};
// 复数加法 // [!code focus]
Complex Complex::add(Complex& other){// [!code focus]
    Complex result;// [!code focus]
    result.real = this->real + other.real;// [!code focus]
    result.imag = this->imag + other.imag;// [!code focus]
    return result;// [!code focus]
}// [!code focus]
// 复数减法 // [!code focus]
Complex Complex::subtract(Complex& other){// [!code focus]
    Complex result;// [!code focus]
    result.real = this->real - other.real;// [!code focus]
    result.imag = this->imag - other.imag;// [!code focus]
    return result;// [!code focus]
}// [!code focus]
// 复数乘法 // [!code focus]
Complex Complex::multiply(Complex& other){// [!code focus]
    Complex result;// [!code focus]
    result.real = this->real * other.real - this->imag * other.imag;// [!code focus]
    result.imag = this->real * other.imag + this->imag * other.real;// [!code focus]
    return result;// [!code focus]
}// [!code focus]
// 复数除法 // [!code focus]
Complex Complex::divide(Complex& other){// [!code focus]
    Complex result;// [!code focus]
    if (other.real == 0 && other.imag == 0) {// [!code focus]
        return Complex(0, 0); // 返回(0,0)// [!code focus]
    }// [!code focus]
    double denominator = other.real * other.real + other.imag * other.imag;// [!code focus]
    result.real = (this->real * other.real + this->imag * other.imag) / denominator;// [!code focus]
    result.imag = (this->imag * other.real - this->real * other.imag) / denominator;// [!code focus]
    return result;// [!code focus]
}// [!code focus]
int main() {   // 测试Complex类
    Complex c1(3, 4);    // 创建复数 3+4i
    Complex c2(1, -2);   // 创建复数 1-2i  
    Complex result;     // 创建复数 0-0i 
    result = c1.add(c2); // 加法
    result.show();
    result = c1.subtract(c2);// 减法
    result.show();
    result = c1.multiply(c2);// 乘法
    result.show();
    result = c1.divide(c2);// 除法
    result.show();
}
```
:::
## 2.C++与C语言的部分不同
### 2.1 头文件
-   **C 语言**：标准库主要提供了一些基本的输入输出、字符串处理、数学运算等功能的函数。例如`<stdio.h>`、`<string.h>`、`<math.h>`等。
-   **C++**：标准库不仅包含了 C 语言的标准库，还提供了更丰富的功能，如标准模板库（STL）。STL 包含了容器（如`vector`、`list`、`map`等）、算法（如`sort`、`find`等）和迭代器等，大大提高了开发效率。其中万能头文件`<bits/stdc++.h>`更是可以包含所有C++的库。 其中，vector等将在后文详细介绍。

### 2.2 标准输入输出
-   **C 语言**：主要使用标准输入输出函数，如`scanf`和`printf`。这些函数需要指定格式说明符，使用时需要注意数据类型的匹配。例如：
```c
#include <stdio.h>
int main() {
    int num;
    printf("请输入一个整数: ");
    scanf("%d", &num);
    printf("你输入的整数是: %d\n", num);
    return 0;
}
```
-   **C++**：使用流对象`cin`和`cout`进行输入输出，它们会自动处理数据类型，使用起来更加方便。例如：

```cpp
#include <iostream>
using namespace std;
int main() {
    int num;
    cout << "请输入一个整数: ";
    cin >> num;
    cout << "你输入的整数是: " << num << endl;
    return 0;
}
```

### 2.3 申请内存
-   **C 语言**：使用`malloc`、`calloc`、`realloc`和`free`函数进行动态内存分配和释放。例如：
```c
#include <stdio.h>
#include <stdlib.h>
int main() {
    int *arr = (int *)malloc(5 * sizeof(int));// [!code focus]
    if (arr == NULL) {// [!code focus]
        printf("内存分配失败\n");// [!code focus]
        return 1;// [!code focus]
    }
    // 使用数组
    free(arr);  // 释放内存
    return 0;
}
```
-   **C++**：除了可以使用 C 语言的内存管理函数外，还引入了`new`和`delete`运算符进行动态内存分配和释放。`new`会自动调用对象的构造函数，`delete`会自动调用对象的析构函数。例如：
```cpp
#include <iostream>
int main() {
    int *arr = new int[5];
    if (arr == nullptr) {
        std::cout << "内存分配失败" << std::endl;
        return 1;
    }
    // 使用数组
    delete[] arr;  // 释放内存
    return 0;
}
```
### 2.4 函数重载
-   **C 语言**：不支持函数重载，即不能定义同名但参数列表不同的函数。每个函数必须有唯一的名称。
-  **C++**：支持函数重载，允许定义同名但参数列表不同的函数，编译器会根据调用时提供的参数类型和数量来选择合适的函数。在上文面向对象已经提及。

### 2.5 异常处理
-   **C 语言**：没有内置的异常处理机制，通常使用返回错误码的方式来处理错误。例如，函数返回特定的错误码表示出现了某种错误，调用者需要检查返回值来处理错误。
-  **C++**：引入了异常处理机制，使用`try`、`catch`和`throw`关键字来处理异常。当程序出现异常时，可以使用`throw`抛出异常，在`try`块中捕获并处理异常。例如：
```cpp
#include <iostream>
int divide(int a, int b) {
    if (b == 0) {
        throw "除数不能为零";
    }
    return a / b;
}
int main() {
    try {
        int result = divide(10, 0);
        std::cout << "结果: " << result << std::endl;
    } catch (const char* msg) {
        std::cout << "异常: " << msg << std::endl;
    }
    return 0;
}
```
### 2.6 引用
回到我们的swap函数，虽然C语言也写过这样的函数，但是使用了指针看起来不太自然。而C++提供了引用，虽然在功能上弱于指针，但是减少了出错的可能性，提高了代码的可读性。
```C++
#include <iostream>
using namespace std;
void swap2(int &a,int &b){// [!code focus]
	int t=a;a=b;b=t;// [!code focus]
}
```
这就是传址调用，在C语言中我们已经介绍过，但是实际上，这是C++的功能。  
可能会有人注意到为什么我们使用的是swap2，而不是swap作为函数名，这是因为在`<algorithm>`头文件中，提供了功能更为强大的`swap`函数。
## 3.STL
STL是Cpp中最为重要的一个库，也是和C语言最大的不同之一。包含了诸多在计算机科学领域里常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。其中封装了很多好用的“容器”，包括：向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。  

###  3.1 六大组件简介
#### 3.1.1 STL组件
- Container(容器) 各种基本数据结构
- Adapter(适配器) 可改变containers、Iterators或Function object接口的一种组件
- Algorithm(算法) 各种基本算法如sort、search…等
- Iterator(迭代器) 连接containers和algorithms
- Function object(函数对象)
- Allocator(分配器)
#### 3.1.2 容器
容器类是容纳、包含一组元素或元素集合的对象。     
七种基本容器：  
向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）  
标准容器的成员绝大部分都具有共同的名称。
容器可以通过其元素的存储方式分为两种：  
- 序列式容器（Sequence containers）：其中每个元素均有固定位置——取决于插入时机和地点，和元素值无关。（vector、deque、list）  
-  关联式容器（Associative containers）：元素位置取决于特定的排序准则以及元素值，和插入次序无关。（set、multiset、map、multimap）   


#### 3.1.3 STL迭代器
Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。  
迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了*，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator.

#### 3.1.4 算法
函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。   
STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。  
算法部分主要由头文件`<algorithm>`，`<numeric>`和`<functional>`组成。   
`<algorithm>`是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。   
`<numeric>`体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。  
`<functional>`中则定义了一些模板类，用以声明函数对象。  
STL中算法大致分为四类： 
-   非可变序列算法：指不直接修改其所操作的容器内容的算法。
-   可变序列算法：指可以修改它们所操作的容器内容的算法。
-   排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。
-   数值算法：对容器内容进行数值计算。  
具体的算法将在后文详细介绍。

### 3.2 【补充】String
在C语言中，我们知道字符串是以 '\0' 结尾的一些字符的集合，而为了操作方便，C标准库中提供了一些str系列的库函数，但是这些库函数与字符串是分离开的，不太符合OOP（面向对象编程）的思想，而且底层空间需要用户自己进行管理，稍不留神可能还会导致越界访问。  
而STL为了体现C++中的OOP的思想，设计了string这一容器，它将相关算法封装到string的内部，当用户定义string对象时可以直接调用相关算法。  
当然，我们仍然可以使用字符数组，但是为了更简洁自然，string类型往往更好。例如：C++中的cin/cout可以直接读写string类型，却不能读写字符数组；string类型可以直接像整数类型一样相加，而在C语言中只能使用strcat函数。  
【例】输入的数据每行包括若干个以空格隔开的整数，输出每行中所有整数的和。且此代码只能使用字符去处理。  
```C++
#include <iostream>
#include <string>
#include <sstream>
using namespace std;
int main(){
	string line;
	while(getline(cin,line)){
		int sum = 0,x;
		stringstream ss(line);
		whlie (ss>>x) sum+=x;
		cout<<sum<<"\n";
	}
	return 0;
}
```
		