# 一.C语言
## 1.基础知识
### 1.1 顺序结构设计
#### 1.1.1 赋值语句
`“=”`在C语言中为赋值运算符，而不是“等于”的布尔类型判断，其一半形式为：  
```C
变量 = 表达式
```
**在赋值语句使用时，需要注意：**
（1）由于赋值运算`“=”`右边的表达式也可以是赋值表达式，因此，下列形式
```C
变量 = （变量 = 表达式）
```
是成立的，从而有嵌套的情形，这时候，语句应从右向左一一赋值。  
（2）进行赋值运算时，如果赋值运算符两边的数据类型不同，系统将自动进行类型转换，也就是将右边的数据类型转换为左边的。  

#### 1.1.2 运算符和表达式
|运算符类型 |具体运算符 |用法 |
|----------------|--------------------------------| ------------------------------|
|算数运算符|`+,-,*,/,%,++,- -` |用于数值运算|
|关系运算符|`>,<,==,<=,>=,!= `|用于比较运算 |
|逻辑操作符|与（`&&`）,或,非（`！`）|用于逻辑运算|
|位操作运算符|位与（`&`）,位或,位非（`~`）,异或(`^`),左移（`<<`），右移（`>>`）|按二进制进行计算|
|赋值运算符|`=,+=,-=,*=,/=,%=,&=,^=,>>=,<<=`|后面三种为复合位运算符|
|条件运算符|`x？a：b`|三目运算符，x真为a|
|逗号运算符|`，`|将若干表达式组合|
|指针运算符|取内容（`*`），取地址（`&`）|很重要
|求字节运算符|`sizeof`|用于计算数据类似占据字节数|
|特殊运算符|括号`（）`，下标`[]`等||  

一些运算符之间有优先级别：（从低到高）  
赋值运算符-->逻辑运算符-->关系运算符-->算数运算符  
常用函数与Python类似，略。  
#### 1.1.3 常量与变量
在 C 语言中，声明常量主要有两种常见的方式：使用 `#define` 预处理指令和使用 `const` 关键字。常量种类分为整型常量，实型常量，字符常量。  
 
 1.使用  `#define`  预处理指令：`#define` 是 C 语言的预处理指令，用于创建宏定义。通过 `#define` 可以定义一个标识符来代表一个常量值，这个标识符在编译前会被预处理器直接替换为对应的值。
 例：
```C
// 定义一个表示圆周率的常量
#define PI 3.14159
```
::: warning 
（1） `#define` 定义的常量没有类型信息，只是简单的文本替换，可能会导致一些潜在的问题，比如在复杂表达式中可能会出现意外的替换结果。  
（2）常量名通常使用大写字母，这是一种编程惯例，用于区分常量和变量。  
:::
2.使用 `const` 关键字：`const` 关键字用于声明一个只读的变量，即一旦初始化后，其值就不能再被修改。`const` 定义的常量具有类型信息，更符合现代编程的类型安全原则。
例：
```c
 // 定义一个表示重力加速度的常量
    const double GRAVITY = 9.8;
```
::: warning 
（1）`const` 定义的常量必须在声明时进行初始化，之后不能再对其进行赋值操作。  
（2）`const` 常量具有类型，编译器会进行类型检查，提高了代码的安全性和可读性。  
:::
#### 1.1.4 标准数据类型
**1. 整数类型**
整数类型用于表示整数，根据占用的内存空间和表示范围的不同，可分为以下几种：  
![P-R曲线](https://s21.ax1x.com/2025/03/15/pEacf1K.png)  
其他数组、指针等类型略。  

### 1.2 控制结构设计
#### 1.2.1 选择结构
在 C 语言中，选择结构用于根据条件的真假来决定执行不同的代码块。选择结构可以让程序根据不同的情况做出不同的决策，增强程序的灵活性和实用性。C 语言提供了两种主要的选择结构：`if` 语句和 `switch` 语句。下面将详细介绍这两种选择结构。  
**1.`if` 语句**  
`if` 语句是 C 语言中最基本的选择结构，它根据条件表达式的结果来决定是否执行特定的代码块。`if` 语句有以下几种形式：  
（1）简单 `if` 语句  
**语法**：  
```c
if (条件表达式) {
    // 当条件表达式为真（非零）时执行的代码块
}
```
（2）`if-else` 语句
```c
if (条件表达式) {
    // 当条件表达式为真（非零）时执行的代码块
} else {
    // 当条件表达式为假（零）时执行的代码块
}
```
（3） `if-else if-else` 语句 
```c
if (条件表达式 1) {
    // 当条件表达式 1 为真时执行的代码块
} else if (条件表达式 2) {
    // 当条件表达式 1 为假，条件表达式 2 为真时执行的代码块
} else if (条件表达式 3) {
    // 当条件表达式 1 和 2 都为假，条件表达式 3 为真时执行的代码块
}
// 可以有多个 else if 语句
else {
    // 当所有条件表达式都为假时执行的代码块
}
```
**2.switch语句**  
`switch` 语句用于根据一个表达式的值来选择执行多个代码块中的一个。它通常用于处理多个固定值的情况。  
**语法**：
```c
switch (表达式) {
    case 常量表达式 1:
        // 当表达式的值等于常量表达式 1 时执行的代码块
        break;
    case 常量表达式 2:
        // 当表达式的值等于常量表达式 2 时执行的代码块
        break;
    // 可以有多个 case 语句
    default:
        // 当表达式的值与所有 case 后面的常量表达式都不匹配时执行的代码块
        break;
}
```
#### 1.2.2 循环结构
在 C 语言中，循环结构用于重复执行一段代码，直到满足特定条件为止。循环结构可以提高代码的复用性和效率，避免代码的重复编写。C 语言提供了三种主要的循环结构：`for` 循环、`while` 循环和 `do-while` 循环，下面将详细介绍这三种循环结构。  
 **1. `for` 循环**  
`for` 循环是一种在已知循环次数的情况下非常常用的循环结构，它将循环控制的初始化、条件判断和循环变量更新都集中在一个语句中。  
```c
for (初始化表达式; 条件表达式; 更新表达式) {
    // 循环体，要重复执行的代码块
}
```
**2.while循环**
```c
while (条件表达式) {
    // 循环体，要重复执行的代码块
}
```
**3.do-while循环**
```c
do {
    // 循环体，要重复执行的代码块
} while (条件表达式);
```
::: tip 
`while` 循环先判断 `条件表达式` 的真假，只有当条件为真（非零）时，才会执行循环体中的代码。而`do-while` 循环先执行一次循环体中的代码，然后再判断 `条件表达式` 的真假，以决定是否继续下一次循环。
:::

**循环例题**（[Noip2012普及组第1题](https://www.luogu.com.cn/problem/P1075)）  
已知正整数$n$是两个不同的质数的乘积，试求出两者中较大的那个质数。  
输入一个正整数 $n$。输出一个正整数 $p$，即较大的那个质数。（$1≤n≤2×10^9$）  
```c
#include <stdio.h>
#include <math.h>
int main() {
    int n, x;
    scanf("%d", &n);
    int sqrtn = (int)floor(sqrt((double)n));//floor:向下取整
    for (int i = 2; i <= sqrtn; i++) {
        if (n % i == 0) {
            x = n / i;
        }
    }
    printf("%d\n", x);
    return 0;
}
```
## 2.数组
### 2.1 一维数组
**一维数组的定义：** 当数组中每个元素只带有一个下标，这样的数组称为一维数组。  
**数组的定义格式：** 
```c
类型标识符 数组名[常量表达式]
```
:::tip
（1）数组名的命名规则与变量名的命名规则一致。  
（2）常量表达式表示数组元素的个数，可以是常量和符号变量， **但不能是变量** 。
:::
例如：  
```c
int a[10];  //数组a的定义是合法的
int b[n];  //数组b的定义是非法的
```
::: warning
需要注意的是，a[10]有10个元素分别为a[0]-a[9]，a[10]并不属于该数组的空间范围。但是又因为C语言的 **“语言特性”** 写到a[10]的时候虽然数组越界了，但是并不会报错，而是会随机输出一个大数。所以防止数组越界是很重要的。
:::
**一维数组的引用：**   
一维数组的引用格式：
```c
数组名[下标]
```
 :::tip
 （1）下标可以是任意值为整型的表达式，该表达式里可包含变量和函数调用。但是应该注意下标值不要越界。  
 （2）在实际应用中，对下标变量的灵活控制有时会起到意想不到的作用。  
 （3）在 C 语言中，只能逐个引用数组元素，不能一次引用整个数组。  
 例如：int a[100],b[100];a=b;这样的写法是非法的。  
 （4）数组元素可以像同类型的普通变量那样使用，对其进行赋值和运算的操作。
 :::
 **数组越界：** 
 :::warning
 使用数组一定需要注意：  
 （1）数组元素下标值为非负整数！   
 （2）在定义元素个数的下标范围内使用！
 :::
 
 ### 2.2 二维数组
 **定义：** 与一维数组类似，当一维数组的元素的类型也是一维数组时，便构成了二维数组。二维数组定义的一般格式:
```c
数据类型 数组名[常量表达式1][常量表达式2]
```
例如:int a[4][10];    
a数组实际上是一个4行10列的表格，表格中可储存40个元素。第一行第一列对应a[0][0]，第n行第m列对应a[n-1][m-1]。  
:::tip
当定义的数组下标有多个时，我们称其为多维数组，下标的个数并不局限在一个或者两个，例如三维数组b和四维数组c:   
```c
int b[100][3][5];
int c[100][100][3][5];
```
:::
**二维数组的引用：**  与一维数组的区别在于必须给出两个下标，引用的格式为：
```c
<数组名>[下标1][下标2]
```
:::danger
注意不要越界！
:::

**二维数组的初始化：** 与一维数组类似，可以将每一行分开来写在各自括号里，也可以不分开，写在一个括号里：
```c
int a[4][2]={{1,0},{0,1}.{-1,0},{0,-1}};
int a1[4][2]={1,0,0,1,-1,0,0,-1};//尽量不要使用！
```

### 2.3 字符类型和字符数组
**字符类型：** 字符类型为由一个字符组成的字符常量或字符变量。  
```c
//字符常量定义
const 字符常量 = '字符'；
//字符变量定义
char 字符变量;
```
字符类型是一个有序类型，字符的大小顺序按其ASCII码的大小决定。  

 
 **字符数组：** 字符数组是指元素为字符的数组，其也有一维、二维和三维之分。  
 **字符数组的定义格式：** 字符数组定义格式和一般数组相同，所不同的是数组类型为字符型，第一个元素同样是从`ch1[0]`开始，而不是`ch1[1]`。具体格式如下：
 ```c
 [存储类型] char 数组名[常量表达式]...;
 //E.g
 char ch1[5];  //ch1是有5个字符元素的一维字符数组
 char ch2[3][5]; //ch2是有15个字符元素的二维字符数组
 ```
 **字符数组的赋值：** 分为两种方法，分别为 **用字符初始化** 和 **用字符串初始化**。  
 （1）用字符初始化：  
 例如：
 ```c
 char chr1[5]={'a','b','c','d','e'};
 ```
 初始值表中的每个数据项是一个字符，当初始值个数少于元素个数时，从首字符开始赋值，剩余元素默认为空字符。  
 字符数组中也可以存放若干个字符，也可以用来存放字符串。两者的 **区别** 是字符串有结束符`\0`，反过来说，在一维字符数组中存放带有结束符的若干个字符称为字符串。字符串是一维数组，但是一维字符数组不等于字符串。  
 （2）用字符串初始化：  
 用一个字符串初始化一个一维字符数组，可以写成：
 ```c
 char chr2[5]="abcd";
 ```
 :::warning
 使用此格式要注意字符串的长度应该小于字符数组的大小或等于字符数组的大小 **减1** ，因为c语言会自动在最后补一个`\0`。  
 :::
 同理，对二维字符数组来说，可存放若干个字符串。可使用由若干个字符数组组成的初始值表给二位字符数组初始化。  
 （3）数组元素赋值：  
 单独给每个元素赋一个字符值。例如：  
 ```c
 char chr[3];
 chr[0] = 'a';chr[1] = 'b';chr[2] = 'c';
 ```
 对多维字符数组也同理。  
 :::info
 **字符常量和字符串常量的区别**  
 （1）两者的定界符不同，字符常量由 **单引号** 括起来，字符串常量由 **双引号** 括起来；   
 （2）字符常量只能是单个字符，而字符串常量则可以是多个字符；  
 （3）可以把一个字符常量赋值给一个字符变量，但不能把一个字符串常量赋给一个字符串变量；  
 （4）字符常量占一个字节，而字符串常量占用字节数等于字符串的字节数加1（末尾的`\0`占据一个字节）。
 :::
 
 **字符串输入输出**  
 
 * **输入：**  
 * 使用`scanf`函数：格式控制字符串中使用`%s`来读取字符串。当使用`scanf`输入字符串时，它会从输入流中读取字符，直到遇到空格、制表符、换行符或者文件结束符为止。
```c
char str[20];
    printf("请输入一个字符串：");
    scanf("%s", str);
    printf("你输入的字符串是：%s\n", str);
```
:::warning
注意，`scanf`函数在读取字符串时不会检查数组是否越界，所以要确保输入的字符串长度不超过字符数组的大小，否则会导致缓冲区溢出，引发未定义行为。
:::
* 使用`gets`函数（不推荐）:`gets`函数从标准输入流中读取一行字符串，包括空格，并将其存储到字符数组中，它会自动在字符串末尾添加`\0`。
 ```c
char str[20];
    printf("请输入一个字符串：");
    gets(str);
    printf("你输入的字符串是：%s\n", str);
```
:::warning
由于`gets`函数不限制输入的字符数量，容易导致缓冲区溢出，存在安全隐患，因此在实际应用中不推荐使用。
:::
* 使用`fgets`函数:`fgets`函数可以从指定的文件流中读取一行字符串，也常用于从标准输入流`stdin`中读取字符串。它的优点是可以指定读取的字符数量，从而避免缓冲区溢出。
 ```c
char str[20];
    printf("请输入一个字符串：");
    fgets(str, 20, stdin);// 从标准输入读取一行字符串，最多读取 19 个字符（留一个位置给 '\0'）
    // fgets会读取换行符，所以如果需要去除换行符，可以使用以下方法
    if (str[strlen(str) - 1] == '\n') {
        str[strlen(str) - 1] = '\0';
    }
    printf("你输入的字符串是：%s\n", str);
```
 * **输出：**  
 * 使用`printf`函数：-   格式控制字符串中使用`%s`来输出字符串。`printf`函数会从给定的字符数组起始地址开始，依次输出字符，直到遇到`\0`结束符为止。
 ```c
	char str[] = "Hello, World!";
    printf("字符串为：%s\n", str);
```
* 使用`puts`函数：`puts`函数用于将一个字符串输出到标准输出流，并在输出完字符串后自动换行。
```c
	char str[] = "Hello, World!";
    puts(str);
```
* 使用`fputs`函数：`fputs`函数可以将一个字符串输出到指定的文件流中，也可以输出到标准输出流`stdout`。
 ```c
	char str[] = "Hello, World!";
    fputs(str, stdout);
```

**字符串String类型：** C语言并无内置string类型，等到C++笔记再进行讨论。

**字符串处理函数：**  
#### 2.3.1.字符串长度计算：strlen  
* **功能：** 计算字符串的长度，即字符串中字符的个数。返回字符串的长度，格式为size_t。
:::warning
**strlen**得到的字符个数不包括字符串结束符`\0`
:::
示例代码：  
```c
char str[] = "Hello, World!";
size_t len = strlen(str);
printf("字符串的长度是: %zu\n", len);//%zu是size_t的输出符，实际上，用%d也是可以的，也更符合常识。
```
#### 2.3.2.字符串复制：strcpy与strncpy
* （1）**strcpy**
* **功能：** 将一个字符串复制到另一个字符数组中。返回值是一个指向目标字符数组的指针。  
:::info
原字符串 `dest` 末尾的 `'\0'` 会被覆盖，当 `src` 字符串复制完成后，`strcat` 会在新字符串的末尾添加一个 `'\0'`，以此来表示新字符串的结束。
:::
示例代码：
```c
char src[] = "Hello";
char dest[10];
strcpy(dest, src);
printf("复制后的字符串: %s\n", dest);//%s是用于处理字符串的
```   

* （2）**strncpy**
* **功能：** 将源字符串的前 `n` 个字符复制到目标字符数组中。 返回指向目标字符数组的指针。 
:::warning
如果源字符串的长度小于 `n`，则在目标字符数组后面填充 `\0` 直到达到 `n` 个字符；如果源字符串的长度大于等于 `n`，则不会自动添加 `\0`。注意不要越界！
:::
示例代码：
```c
char src[] = "Hello";
char dest[3];
strncpy(dest, src, 2);
dest[2] = '\0';  // 手动添加字符串结束符
printf("复制后的字符串: %s\n", dest);
```
#### 2.3.3.字符串连接：strcat与strncat
* （1）**strcat**
* **功能：** 将一个字符串连接到另一个字符串的末尾。返回指向目标字符数组的指针。 
示例代码：
```c
char dest[20] = "Hello, ";
char src[] = "World!";
strcat(dest, src);
printf("连接后的字符串: %s\n", dest);
```

* （2）**strncat**
* **功能：** 将源字符串的前 `n` 个字符连接到目标字符数组的末尾。 返回指向目标字符数组的指针。 
:::warning
连接后会自动在结果字符串末尾添加 `'\0'`。
:::
示例代码：
```c
char dest[20] = "Hello, ";
char src[] = "World!";
strncat(dest, src, 3);
printf("连接后的字符串: %s\n", dest);
```
####  2.3.4.字符串比较：strcmp与 strncmp
* （1）**strcmp**
* **功能：** 比较两个字符串的大小($ASC2$)。如果 `s1` 小于 `s2`，返回一个负整数；如果 `s1` 等于 `s2`，返回 0；如果 `s1` 大于 `s2`，返回一个正整数。（返回值通常是两个不同字符的$ASC2$码值之差）
:::tip
这个函数是逐个字符比较，只要遇到相同位置返回值不为0的就不会继续比较。
:::
示例代码：
```c
char str1[] = "apple";
char str2[] = "banana";
int result = strcmp(str1, str2);
if (result < 0) {
    printf("%s 小于 %s\n", str1, str2);
} else if (result == 0) {
    printf("%s 等于 %s\n", str1, str2);
} else {
    printf("%s 大于 %s\n", str1, str2);
}//比较首字母a和b即可以得到apple<banana
```

* （2）**strncmp**
* **功能：** 比较两个字符串的前 `n` 个字符的大小。 与 `strcmp` 类似，根据前 `n` 个字符的比较结果返回相应的值。
示例代码：
```c
char str1[] = "apple";
char str2[] = "applet";
int result = strncmp(str1, str2, 3);
if (result == 0) {
    printf("前 3 个字符相等\n");
}
```

#### 2.3.5.字符串查找：strchr与strstr
* （1）**strchr**
* **功能：** 在字符串中查找指定 **字符** 第一次出现的位置。如果找到，返回指向该字符的指针；如果未找到，返回 `NULL`。
示例代码：
```c
char str[] = "Hello, World!";
char *pos = strchr(str, 'o');
if (pos != NULL) {
    printf("字符 'o' 第一次出现的位置是: %ld\n", pos - str);
} else {
    printf("未找到字符 'o'\n");
}
```

* （2）**strstr**
* **功能：**在字符串中查找指定子字符串第一次出现的位置。如果找到，返回指向子字符串的指针；如果未找到，返回 `NULL`。
示例代码：
```c
char str[] = "Hello,World!";
char *sub_str = "World";
char *pos = strstr(str, sub_str);
if (pos != NULL) {
    printf("子字符串 '%s' 第一次出现的位置是: %ld\n", sub_str, pos - str);
} else {
    printf("未找到子字符串 '%s'\n", sub_str);
}
```
#### 2.3.6.字符串分割：strtok
* **功能：** 将字符串按指定的分隔符进行分割。返回分割出的子字符串的指针，如果没有更多的子字符串，返回 `NULL`。
示例代码：
```c
char str[] = "Hello,World,How,Are,You";
char *token = strtok(str, ",");//*是指针运算符，在后面会提到
while (token != NULL) {
    printf("%s\n", token);
    token = strtok(NULL, ",");
}
```
## 3.函数
### 3.1  函数的定义
**语法：**
```c
数据类型 函数名(形式参数表)
{
	函数体  //执行语句
}
 ```
 :::info
 * 函数的数据类型是函数的返回值类型（若数据类型为void，则无返回值）  
 * 函数名是标识符，一个程序中除了主函数名必须为main外，其余函数的名字可以任意选取，最好取有助于记忆的名字    
 * 形式参数（简称 **形参** ）表可以是空的（无参函数），也可以有多个形参，形参间用逗号隔开，不管有无参数，函数名后的圆括号都必须要有。形参必须有 **类型说明** ，形参可以是变量名，数组名或指针名，其作用是实现主调函数与被调函数之间的关系、
 * 函数中最外层一对花括号`{}`括起来的语句组成了一个函数的函数体。函数体实际上是一个复合语句，它可以没有任何类型说明而只有语句，也可以两者都没有，即空函数
 * 函数 **不允许嵌套定义** 。在一个函数内定义另一个函数是非法的，但是 **允许嵌套使用** 
 :::
 **举例：**
 ```c
 //定义一个函数，返回两个数中的较大数
 int max(int x,int y){
	 return x>y?x:y //三目运算符
}
```
### 3.2 函数的形式
函数的形式从结构上说有三种：无参函数，有参函数和空函数。  
**（1）无参函数**
* 顾名思义为没有参数传递的函数，无参函数一般不需要带回函数值，所以函数类型说明为void  

**（2）有参函数**
* 有参数传递，一般需要带回函数值，例如`int max(int x,int y)`  

**（3）有参函数**
* 函数体只有一对花括号，花括号内没有任何语句，只起到占位的作用，方便后面添加函数

### 3.3 函数的声明和调用
#### 3.3.1 函数的声明
调用函数之前需要声明函数原型，在主调函数中或所有函数定义之前，按照如下形式声明：
```c
类型说明符 被调函数名(含类型说明的参数表)
```
如果是在所有函数定义之前声明了函数原型，那么该函数原型在本程序文件中任意地方都有效，但是要是在某个主调函数内部声明了函数原型，那么该原型就只在这个函数内部有效。  
下面对`js()`函数原型声明是合法的。
```c
int js(int n);
int js(int);//也是对的
```
#### 3.3.2 函数的调用
声明了函数原型后，我们便可以按照如下形式调用函数:
```c
函数名（实参列表） 
```
实参列表中应该给出与函数原型形参列表相同个数、类型相同的实参。在主调函数中的参数称为实参，实参一般具有确定的值，可以是常量，表达式，也可以是已有确定值的变量、数组或指针名。函数调用可以作为一条语句，此时函数可以无返回值；函数调用也可以出现在表达式中，这时就必须有一个明确的返回值。

#### 3.3.3 函数的返回值
-   函数返回值由`return`语句给出，一个函数只能有一个返回值。
-   返回值类型在函数定义时指定，如`int func()`返回整型，`void func()`表示无返回值。
-   若未指定返回值类型，默认是`int`。返回值可用于赋值、传参等后续操作。
- 函数的返回语句也可以是`return`，此时函数无返回值，而只是把流程转向主调函数。

### 3.4 函数的传值与传址调用
#### 3.4.1 函数的传值调用
**特点：** 将调用函数的实参表中的实参值依次传递给被调用函数的形参表中的形参。要求个数相等，类型相同。函数的调用过程实际上是对栈（在数据结构中会介绍）。  
传值调用是将实参的数据值传给形参，但是实参本身并不发生改变，简称 **单向值传递** ，下面以一个失败的$swap$函数举例：（$swap$意为交换，要交换两个数字的值）
```c
void swap(int a,int b){
	int temp=a;a=b;b=temp;//交换a和b的值
}
int main(){
	int c=1,d=2;
	swap(c,d);
	scanf("%d,%d",c,d);
	return 0;
}
```
当我们运行这个程序后，发现$c$和$d$依然是1和2，说明它们的值并没有被成功的交换，因为我们只是把$c$和$d$的**值**传递给了形式参数$a$和$b$，$c$和$d$本身没有发生任何变化，即实参的值未发生改变，交换失败。那么如何交换成功呢？

#### 3.4.2 函数的传址调用（可学完指针再来看）
顾名思义，传址调用就是传递的**地址**，我们知道数据在计算机内是通过**内存空间**存储的，每个元素都有它的一块**地址**，我们将实参的地址传递给形参，那么随着形参的地址交换，不就可以成功的把实际参数的地址也交换了吗？——确实如此：
```c
void swap(int &a,int &b){//&是取地址符，得到的是地址
	int temp=a;a=b;b=temp;//交换a和b的值
}
int main(){
	int c=1,d=2;
	swap(c,d);
	scanf("%d,%d",c,d);
	return 0;
}
```
可以发现输出结构确实变成了2和1，这就说明这个函数生效了。这就是函数的传址调用。

### 3.5 全局变量、局部变量以及其作用域
#### 3.5.1  全局变量
** 定义**
全局变量是在所有函数外部定义的变量。以下是一个简单示例：
```c
#include <stdio.h>
// 定义全局变量
int globalVar = 10;
void func() {
    // 在函数中可以访问全局变量
    printf("在 func 函数中，全局变量 globalVar 的值为: %d\n", globalVar);
}
int main() {
    // 在 main 函数中也可以访问全局变量
    printf("在 main 函数中，全局变量 globalVar 的值为: %d\n", globalVar);
    func();
    return 0;
}
```
在上述代码中，`globalVar` 就是一个全局变量，它定义在所有函数（`func` 和 `main`）之外。  
* **作用域**
- 全局变量的作用域是从它的定义位置开始，到整个源文件的结束。这意味着在定义位置之后的所有函数都可以直接访问和修改这个全局变量。不过，如果在其他源文件中想使用该全局变量，需要使用 `extern` 关键字进行声明。  
* **生命周期**
- 全局变量的生命周期是整个程序的运行期间。程序开始运行时，全局变量就被创建并分配内存空间；当程序结束时，全局变量所占的内存空间才会被释放。  
:::warning
由于全局变量可以被多个函数访问和修改，可能会导致程序的可维护性和可读性降低，也容易引发意外的副作用。比如多个函数同时修改全局变量，可能会让程序的状态变得难以跟踪和调试。
:::
#### 3.5.2  局部变量
* **定义**
局部变量是在函数内部或者代码块（如 `if`、`for`、`while` 等语句块）内部定义的变量。示例如下：
```c
#include <stdio.h>
void func() {
    // 定义局部变量
    int localVar = 20;
    printf("在 func 函数中，局部变量 localVar 的值为: %d\n", localVar);
}
int main() {
    func();
    // 下面这行代码会报错，因为 localVar 是 func 函数的局部变量，main 函数无法访问
    // printf("在 main 函数中访问 localVar: %d\n", localVar);
    return 0;
}
```
在 `func` 函数内部定义的 `localVar` 就是一个局部变量。
 * **作用域**
- 局部变量的作用域仅限于定义它的函数或者代码块内部。在函数或代码块外部，无法访问这个局部变量。例如在上面的代码中，`main` 函数就不能访问 `func` 函数内部定义的 `localVar`。

* **生命周期**
- 局部变量的生命周期从进入定义它的函数或代码块开始，到离开该函数或代码块结束。当程序执行到定义局部变量的位置时，系统会为该变量分配内存空间；当离开该函数或代码块时，系统会自动释放该变量所占的内存空间。
:::warning
局部变量可以避免不同函数之间的变量命名冲突，提高代码的安全性和可维护性。不同函数内部可以定义同名的局部变量，它们彼此独立，互不影响。
:::

:::danger
全局变量数组初始全部为0，局部变量值是随机的，要初始化初始值，局部变量受栈空间大小限制，大数组需要注意，但是全局变量则可以开大数组。
:::

### 3.6 函数的递归
何为递归？即第$n$项和前面几项的关系。以阶乘函数为例，一般来说，实现一个阶乘函数我们可能会考虑使用循环：
```c
// 定义阶乘函数
int factorial(int n) {
    // 用于存储阶乘结果的变量，初始化为 1
    int result = 1;
    // 如果输入的 n 小于 0，阶乘无定义，这里简单返回 1
    if (n < 0) {
        return 1;
    }
    // 使用 for 循环计算阶乘
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}
```
但是不难注意到，阶乘的第$n$项和其第$n-1$项有着很显然的关系：
$$
factorial(n)=n*factorial(n-1)
$$
于是我们也可以把阶乘函数更加简洁的写成下面这个形式：
```c
// 递归实现阶乘函数
int factorial(int n) {
    if (n == 0) {
        return 1;// 基本情况：0 的阶乘为 1
    } 
    else {
        return n * factorial(n - 1);
    }
}
```
这就是递归的魅力。

**例题【[# P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)】**  
此题主要是一个递归的思想，语言并不重要，由于用c实现需要高精度的知识，下面用Python解决：
::: code-group
```Python
n = int(input())
if (n == 0):
    print(0)
    exit(0)
a = [1, 1, 2]
for i in range(0, n):
    a[2] = a[0] + a[1]
    a[0] = a[1]
    a[1] = a[2]
    pass
print(a[0])
```

```C++
#include<bits/stdc++.h>
#define N 250//2000位够了，250*8
using namespace std;
int  f[3][N+10],g;
int n;
int main()
{
	f[0][N]=1;f[1][N]=1;scanf("%d",&n);if(!n){puts("0");return 0;}//0要特判
	for(int i=2;i<=n;i++)
	 for(int j=N;j>0;j--)
	  {
	 	f[i%3][j]=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)%100000000;
	    g=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)/100000000;//8个0，别漏了
	  }
	int j=1;
	while(!f[n%3][j]&&j<N) j++;//处理前导0
	for(int i=j;i<=N;i++)
	{
		if(i!=j){//一定别漏了前面这句
		if(f[n%3][i]<1e7) putchar(48);
		if(f[n%3][i]<1e6) putchar(48);
		if(f[n%3][i]<1e5) putchar(48);
		if(f[n%3][i]<1e4) putchar(48);
		if(f[n%3][i]<1e3) putchar(48);
		if(f[n%3][i]<1e2) putchar(48);
		if(f[n%3][i]<1e1) putchar(48);}//补足前导0
		printf("%d",f[n%3][i]);//输出
	}
}
```
:::

## 4.指针