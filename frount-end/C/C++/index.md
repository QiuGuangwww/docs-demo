# C与C++
## C
## 1.基础知识
### 1.1 顺序结构设计
#### 1.1.1 赋值语句
`“=”`在C语言中为赋值运算符，而不是“等于”的布尔类型判断，其一半形式为：  
```C
变量 = 表达式
```
**在赋值语句使用时，需要注意：**
（1）由于赋值运算`“=”`右边的表达式也可以是赋值表达式，因此，下列形式
```C
变量 = （变量 = 表达式）
```
是成立的，从而有嵌套的情形，这时候，语句应从右向左一一赋值。  
（2）进行赋值运算时，如果赋值运算符两边的数据类型不同，系统将自动进行类型转换，也就是将右边的数据类型转换为左边的。  

#### 1.1.2 运算符和表达式
|运算符类型 |具体运算符 |用法 |
|----------------|--------------------------------| ------------------------------|
|算数运算符|`+,-,*,/,%,++,- -` |用于数值运算|
|关系运算符|`>,<,==,<=,>=,!= `|用于比较运算 |
|逻辑操作符|与（`&&`）,或,非（`！`）|用于逻辑运算|
|位操作运算符|位与（`&`）,位或,位非（`~`）,异或(`^`),左移（`<<`），右移（`>>`）|按二进制进行计算|
|赋值运算符|`=,+=,-=,*=,/=,%=,&=,^=,>>=,<<=`|后面三种为复合位运算符|
|条件运算符|`x？a：b`|三目运算符，x真为a|
|逗号运算符|`，`|将若干表达式组合|
|指针运算符|取内容（`*`），取地址（`&`）|很重要
|求字节运算符|`sizeof`|用于计算数据类似占据字节数|
|特殊运算符|括号`（）`，下标`[]`等||  

一些运算符之间有优先级别：（从低到高）  
赋值运算符-->逻辑运算符-->关系运算符-->算数运算符  
常用函数与Python类似，略。  
#### 1.1.3 常量与变量
在 C 语言中，声明常量主要有两种常见的方式：使用 `#define` 预处理指令和使用 `const` 关键字。常量种类分为整型常量，实型常量，字符常量。  
 
 1.使用  `#define`  预处理指令：`#define` 是 C 语言的预处理指令，用于创建宏定义。通过 `#define` 可以定义一个标识符来代表一个常量值，这个标识符在编译前会被预处理器直接替换为对应的值。
 例：
```C
// 定义一个表示圆周率的常量
#define PI 3.14159
```
::: warning 
（1） `#define` 定义的常量没有类型信息，只是简单的文本替换，可能会导致一些潜在的问题，比如在复杂表达式中可能会出现意外的替换结果。  
（2）常量名通常使用大写字母，这是一种编程惯例，用于区分常量和变量。  
:::
2.使用 `const` 关键字：`const` 关键字用于声明一个只读的变量，即一旦初始化后，其值就不能再被修改。`const` 定义的常量具有类型信息，更符合现代编程的类型安全原则。
例：
```c
 // 定义一个表示重力加速度的常量
    const double GRAVITY = 9.8;
```
::: warning 
（1）`const` 定义的常量必须在声明时进行初始化，之后不能再对其进行赋值操作。  
（2）`const` 常量具有类型，编译器会进行类型检查，提高了代码的安全性和可读性。  
:::
#### 1.1.4 标准数据类型
**1. 整数类型**
整数类型用于表示整数，根据占用的内存空间和表示范围的不同，可分为以下几种：  
![P-R曲线](https://s21.ax1x.com/2025/03/15/pEacf1K.png)  
其他数组、指针等类型略。  

### 1.2 控制结构设计
#### 1.2.1 选择结构
在 C 语言中，选择结构用于根据条件的真假来决定执行不同的代码块。选择结构可以让程序根据不同的情况做出不同的决策，增强程序的灵活性和实用性。C 语言提供了两种主要的选择结构：`if` 语句和 `switch` 语句。下面将详细介绍这两种选择结构。  
**1.`if` 语句**  
`if` 语句是 C 语言中最基本的选择结构，它根据条件表达式的结果来决定是否执行特定的代码块。`if` 语句有以下几种形式：  
（1）简单 `if` 语句  
**语法**：  
```c
if (条件表达式) {
    // 当条件表达式为真（非零）时执行的代码块
}
```
（2）`if-else` 语句
```c
if (条件表达式) {
    // 当条件表达式为真（非零）时执行的代码块
} else {
    // 当条件表达式为假（零）时执行的代码块
}
```
（3） `if-else if-else` 语句 
```c
if (条件表达式 1) {
    // 当条件表达式 1 为真时执行的代码块
} else if (条件表达式 2) {
    // 当条件表达式 1 为假，条件表达式 2 为真时执行的代码块
} else if (条件表达式 3) {
    // 当条件表达式 1 和 2 都为假，条件表达式 3 为真时执行的代码块
}
// 可以有多个 else if 语句
else {
    // 当所有条件表达式都为假时执行的代码块
}
```
**2.switch语句**  
`switch` 语句用于根据一个表达式的值来选择执行多个代码块中的一个。它通常用于处理多个固定值的情况。  
**语法**：
```c
switch (表达式) {
    case 常量表达式 1:
        // 当表达式的值等于常量表达式 1 时执行的代码块
        break;
    case 常量表达式 2:
        // 当表达式的值等于常量表达式 2 时执行的代码块
        break;
    // 可以有多个 case 语句
    default:
        // 当表达式的值与所有 case 后面的常量表达式都不匹配时执行的代码块
        break;
}
```
#### 1.2.2 循环结构
在 C 语言中，循环结构用于重复执行一段代码，直到满足特定条件为止。循环结构可以提高代码的复用性和效率，避免代码的重复编写。C 语言提供了三种主要的循环结构：`for` 循环、`while` 循环和 `do-while` 循环，下面将详细介绍这三种循环结构。  
 **1. `for` 循环**  
`for` 循环是一种在已知循环次数的情况下非常常用的循环结构，它将循环控制的初始化、条件判断和循环变量更新都集中在一个语句中。  
```c
for (初始化表达式; 条件表达式; 更新表达式) {
    // 循环体，要重复执行的代码块
}
```
**2.while循环**
```c
while (条件表达式) {
    // 循环体，要重复执行的代码块
}
```
**3.do-while循环**
```c
do {
    // 循环体，要重复执行的代码块
} while (条件表达式);
```
::: tip 
`while` 循环先判断 `条件表达式` 的真假，只有当条件为真（非零）时，才会执行循环体中的代码。而`do-while` 循环先执行一次循环体中的代码，然后再判断 `条件表达式` 的真假，以决定是否继续下一次循环。
:::

**循环例题**（[Noip2012普及组第1题](https://www.luogu.com.cn/problem/P1075)）  
已知正整数$n$是两个不同的质数的乘积，试求出两者中较大的那个质数。  
输入一个正整数 $n$。输出一个正整数 $p$，即较大的那个质数。（$1≤n≤2×10^9$）  
```c
#include <stdio.h>
#include <math.h>
int main() {
    int n, x;
    scanf("%d", &n);
    int sqrtn = (int)floor(sqrt((double)n));//floor:向下取整
    for (int i = 2; i <= sqrtn; i++) {
        if (n % i == 0) {
            x = n / i;
        }
    }
    printf("%d\n", x);
    return 0;
}
```
## 2.数组
### 2.1 一维数组
**一维数组的定义：** 当数组中每个元素只带有一个下标，这样的数组称为一维数组。  
**数组的定义格式：** 
```c
类型标识符 数组名[常量表达式]
```
:::tip
（1）数组名的命名规则与变量名的命名规则一致。  
（2）常量表达式表示数组元素的个数，可以是常量和符号变量， **但不能是变量** 。
:::
例如：  
```c
int a[10];  //数组a的定义是合法的
int b[n];  //数组b的定义是非法的
```
::: warning
需要注意的是，a[10]有10个元素分别为a[0]-a[9]，a[10]并不属于该数组的空间范围。但是又因为C语言的 **“语言特性”** 写到a[10]的时候虽然数组越界了，但是并不会报错，而是会随机输出一个大数。所以防止数组越界是很重要的。
:::
**一维数组的引用：**   
一维数组的引用格式：
```c
数组名[下标]
```
 :::tip
 （1）下标可以是任意值为整型的表达式，该表达式里可包含变量和函数调用。但是应该注意下标值不要越界。  
 （2）在实际应用中，对下标变量的灵活控制有时会起到意想不到的作用。  
 （3）在 C 语言中，只能逐个引用数组元素，不能一次引用整个数组。  
 例如：int a[100],b[100];a=b;这样的写法是非法的。  
 （4）数组元素可以像同类型的普通变量那样使用，对其进行赋值和运算的操作。
 :::
 **数组越界：** 
 :::warning
 使用数组一定需要注意：  
 （1）数组元素下标值为非负整数！   
 （2）在定义元素个数的下标范围内使用！
 :::
 
 ### 2.2 二维数组
 **定义：** 与一维数组类似，当一维数组的元素的类型也是一维数组时，便构成了二维数组。二维数组定义的一般格式:
```c
数据类型 数组名[常量表达式1][常量表达式2]
```
例如:int a[4][10];    
a数组实际上是一个4行10列的表格，表格中可储存40个元素。第一行第一列对应a[0][0]，第n行第m列对应a[n-1][m-1]。  
:::tip
当定义的数组下标有多个时，我们称其为多维数组，下标的个数并不局限在一个或者两个，例如三维数组b和四维数组c:   
```c
int b[100][3][5];
int c[100][100][3][5];
```
:::
**二维数组的引用：**  与一维数组的区别在于必须给出两个下标，引用的格式为：
```c
<数组名>[下标1][下标2]
```
:::danger
注意不要越界！
:::

**二维数组的初始化：** 与一维数组类似，可以将每一行分开来写在各自括号里，也可以不分开，写在一个括号里：
```c
int a[4][2]={{1,0},{0,1}.{-1,0},{0,-1}};
int a1[4][2]={1,0,0,1,-1,0,0,-1};//尽量不要使用！
```

### 2.3 字符类型和字符数组
#### 2.3.1 字符类型
字符类型为由一个字符组成的字符常量或字符变量。  
```c
//字符常量定义
const 字符常量 = '字符'；
//字符变量定义
char 字符变量;
```
字符类型是一个有序类型，字符的大小顺序按其ASCII码的大小决定。  

 
#### 2.3.2 字符数组 
字符数组是指元素为字符的数组，其也有一维、二维和三维之分。  
 **字符数组的定义格式：** 字符数组定义格式和一般数组相同，所不同的是数组类型为字符型，第一个元素同样是从`ch1[0]`开始，而不是`ch1[1]`。具体格式如下：
 ```c
 [存储类型] char 数组名[常量表达式]...;
 //E.g
 char ch1[5];  //ch1是有5个字符元素的一维字符数组
 char ch2[3][5]; //ch2是有15个字符元素的二维字符数组
 ```
 **字符数组的赋值：** 分为两种方法，分别为 **用字符初始化** 和 **用字符串初始化**。  
 （1）用字符初始化：  
 例如：
 ```c
 char chr1[5]={'a','b','c','d','e'};
 ```
 初始值表中的每个数据项是一个字符，当初始值个数少于元素个数时，从首字符开始赋值，剩余元素默认为空字符。  
 字符数组中也可以存放若干个字符，也可以用来存放字符串。两者的 **区别** 是字符串有结束符`\0`，反过来说，在一维字符数组中存放带有结束符的若干个字符称为字符串。字符串是一维数组，但是一维字符数组不等于字符串。  
 （2）用字符串初始化：  
 用一个字符串初始化一个一维字符数组，可以写成：
 ```c
 char chr2[5]="abcd";
 ```
 :::warning
 使用此格式要注意字符串的长度应该小于字符数组的大小或等于字符数组的大小 **减1** ，因为c语言会自动在最后补一个`\0`。  
 :::
 同理，对二维字符数组来说，可存放若干个字符串。可使用由若干个字符数组组成的初始值表给二位字符数组初始化。  
 （3）数组元素赋值：  
 单独给每个元素赋一个字符值。例如：  
 ```c
 char chr[3];
 chr[0] = 'a';chr[1] = 'b';chr[2] = 'c';
 ```
 对多维字符数组也同理。  
 :::info
 **字符常量和字符串常量的区别**  
 （1）两者的定界符不同，字符常量由 **单引号** 括起来，字符串常量由 **双引号** 括起来；   
 （2）字符常量只能是单个字符，而字符串常量则可以是多个字符；  
 （3）可以把一个字符常量赋值给一个字符变量，但不能把一个字符串常量赋给一个字符串变量；  
 （4）字符常量占一个字节，而字符串常量占用字节数等于字符串的字节数加1（末尾的`\0`占据一个字节）。
 :::
 
#### 2.3.3 字符串输入输出 
 
 * **输入：**  
 * 使用`scanf`函数：格式控制字符串中使用`%s`来读取字符串。当使用`scanf`输入字符串时，它会从输入流中读取字符，直到遇到空格、制表符、换行符或者文件结束符为止。
```c
char str[20];
    printf("请输入一个字符串：");
    scanf("%s", str);
    printf("你输入的字符串是：%s\n", str);
```
:::warning
注意，`scanf`函数在读取字符串时不会检查数组是否越界，所以要确保输入的字符串长度不超过字符数组的大小，否则会导致缓冲区溢出，引发未定义行为。
:::
* 使用`gets`函数（不推荐）:`gets`函数从标准输入流中读取一行字符串，包括空格，并将其存储到字符数组中，它会自动在字符串末尾添加`\0`。
 ```c
char str[20];
    printf("请输入一个字符串：");
    gets(str);
    printf("你输入的字符串是：%s\n", str);
```
:::warning
由于`gets`函数不限制输入的字符数量，容易导致缓冲区溢出，存在安全隐患，因此在实际应用中不推荐使用。
:::
* 使用`fgets`函数:`fgets`函数可以从指定的文件流中读取一行字符串，也常用于从标准输入流`stdin`中读取字符串。它的优点是可以指定读取的字符数量，从而避免缓冲区溢出。
 ```c
char str[20];
    printf("请输入一个字符串：");
    fgets(str, 20, stdin);// 从标准输入读取一行字符串，最多读取 19 个字符（留一个位置给 '\0'）
    // fgets会读取换行符，所以如果需要去除换行符，可以使用以下方法
    if (str[strlen(str) - 1] == '\n') {
        str[strlen(str) - 1] = '\0';
    }
    printf("你输入的字符串是：%s\n", str);
```
 * **输出：**  
 * 使用`printf`函数：-   格式控制字符串中使用`%s`来输出字符串。`printf`函数会从给定的字符数组起始地址开始，依次输出字符，直到遇到`\0`结束符为止。
 ```c
	char str[] = "Hello, World!";
    printf("字符串为：%s\n", str);
```
* 使用`puts`函数：`puts`函数用于将一个字符串输出到标准输出流，并在输出完字符串后自动换行。
```c
	char str[] = "Hello, World!";
    puts(str);
```
* 使用`fputs`函数：`fputs`函数可以将一个字符串输出到指定的文件流中，也可以输出到标准输出流`stdout`。
 ```c
	char str[] = "Hello, World!";
    fputs(str, stdout);
```

**字符串String类型：** C语言并无内置string类型，等到C++笔记再进行讨论。

### 2.4 字符串处理函数  
#### 2.4.1.字符串长度计算：strlen  
* **功能：** 计算字符串的长度，即字符串中字符的个数。返回字符串的长度，格式为size_t。
:::warning
**strlen**得到的字符个数不包括字符串结束符`\0`
:::
示例代码：  
```c
char str[] = "Hello, World!";
size_t len = strlen(str);
printf("字符串的长度是: %zu\n", len);//%zu是size_t的输出符，实际上，用%d也是可以的，也更符合常识。
```
#### 2.4.2.字符串复制：strcpy与strncpy
* （1）**strcpy**
* **功能：** 将一个字符串复制到另一个字符数组中。返回值是一个指向目标字符数组的指针。  
:::info
原字符串 `dest` 末尾的 `'\0'` 会被覆盖，当 `src` 字符串复制完成后，`strcat` 会在新字符串的末尾添加一个 `'\0'`，以此来表示新字符串的结束。
:::
示例代码：
```c
char src[] = "Hello";
char dest[10];
strcpy(dest, src);
printf("复制后的字符串: %s\n", dest);//%s是用于处理字符串的
```   

* （2）**strncpy**
* **功能：** 将源字符串的前 `n` 个字符复制到目标字符数组中。 返回指向目标字符数组的指针。 
:::warning
如果源字符串的长度小于 `n`，则在目标字符数组后面填充 `\0` 直到达到 `n` 个字符；如果源字符串的长度大于等于 `n`，则不会自动添加 `\0`。注意不要越界！
:::
示例代码：
```c
char src[] = "Hello";
char dest[3];
strncpy(dest, src, 2);
dest[2] = '\0';  // 手动添加字符串结束符
printf("复制后的字符串: %s\n", dest);
```
#### 2.4.3.字符串连接：strcat与strncat
* （1）**strcat**
* **功能：** 将一个字符串连接到另一个字符串的末尾。返回指向目标字符数组的指针。 
示例代码：
```c
char dest[20] = "Hello, ";
char src[] = "World!";
strcat(dest, src);
printf("连接后的字符串: %s\n", dest);
```

* （2）**strncat**
* **功能：** 将源字符串的前 `n` 个字符连接到目标字符数组的末尾。 返回指向目标字符数组的指针。 
:::warning
连接后会自动在结果字符串末尾添加 `'\0'`。
:::
示例代码：
```c
char dest[20] = "Hello, ";
char src[] = "World!";
strncat(dest, src, 3);
printf("连接后的字符串: %s\n", dest);
```
####  2.4.4.字符串比较：strcmp与 strncmp
* （1）**strcmp**
* **功能：** 比较两个字符串的大小($ASC2$)。如果 `s1` 小于 `s2`，返回一个负整数；如果 `s1` 等于 `s2`，返回 0；如果 `s1` 大于 `s2`，返回一个正整数。（返回值通常是两个不同字符的$ASC2$码值之差）
:::tip
这个函数是逐个字符比较，只要遇到相同位置返回值不为0的就不会继续比较。
:::
示例代码：
```c
char str1[] = "apple";
char str2[] = "banana";
int result = strcmp(str1, str2);
if (result < 0) {
    printf("%s 小于 %s\n", str1, str2);
} else if (result == 0) {
    printf("%s 等于 %s\n", str1, str2);
} else {
    printf("%s 大于 %s\n", str1, str2);
}//比较首字母a和b即可以得到apple<banana
```

* （2）**strncmp**
* **功能：** 比较两个字符串的前 `n` 个字符的大小。 与 `strcmp` 类似，根据前 `n` 个字符的比较结果返回相应的值。
示例代码：
```c
char str1[] = "apple";
char str2[] = "applet";
int result = strncmp(str1, str2, 3);
if (result == 0) {
    printf("前 3 个字符相等\n");
}
```

#### 2.4.5.字符串查找：strchr与strstr
* （1）**strchr**
* **功能：** 在字符串中查找指定 **字符** 第一次出现的位置。如果找到，返回指向该字符的指针；如果未找到，返回 `NULL`。
示例代码：
```c
char str[] = "Hello, World!";
char *pos = strchr(str, 'o');
if (pos != NULL) {
    printf("字符 'o' 第一次出现的位置是: %ld\n", pos - str);
} else {
    printf("未找到字符 'o'\n");
}
```

* （2）**strstr**
* **功能：** 在字符串中查找指定子字符串第一次出现的位置。如果找到，返回指向子字符串的指针；如果未找到，返回 `NULL`。
示例代码：
```c
char str[] = "Hello,World!";
char *sub_str = "World";
char *pos = strstr(str, sub_str);
if (pos != NULL) {
    printf("子字符串 '%s' 第一次出现的位置是: %ld\n", sub_str, pos - str);
} else {
    printf("未找到子字符串 '%s'\n", sub_str);
}
```
#### 2.4.6.字符串分割：strtok
* **功能：** 将字符串按指定的分隔符进行分割。返回分割出的子字符串的指针，如果没有更多的子字符串，返回 `NULL`。
示例代码：
```c
char str[] = "Hello,World,How,Are,You";
char *token = strtok(str, ",");//*是指针运算符，在后面会提到
while (token != NULL) {
    printf("%s\n", token);
    token = strtok(NULL, ",");
}
```
## 3.函数
### 3.1  函数的定义
**语法：**
```c
数据类型 函数名(形式参数表)
{
	函数体  //执行语句
}
 ```
 :::info
 * 函数的数据类型是函数的返回值类型（若数据类型为void，则无返回值）  
 * 函数名是标识符，一个程序中除了主函数名必须为main外，其余函数的名字可以任意选取，最好取有助于记忆的名字    
 * 形式参数（简称 **形参** ）表可以是空的（无参函数），也可以有多个形参，形参间用逗号隔开，不管有无参数，函数名后的圆括号都必须要有。形参必须有 **类型说明** ，形参可以是变量名，数组名或指针名，其作用是实现主调函数与被调函数之间的关系、
 * 函数中最外层一对花括号`{}`括起来的语句组成了一个函数的函数体。函数体实际上是一个复合语句，它可以没有任何类型说明而只有语句，也可以两者都没有，即空函数
 * 函数 **不允许嵌套定义** 。在一个函数内定义另一个函数是非法的，但是 **允许嵌套使用** 
 :::
 **举例：**
 ```c
 //定义一个函数，返回两个数中的较大数
 int max(int x,int y){
	 return x>y?x:y //三目运算符
}
```
### 3.2 函数的形式
函数的形式从结构上说有三种：无参函数，有参函数和空函数。  
**（1）无参函数**
* 顾名思义为没有参数传递的函数，无参函数一般不需要带回函数值，所以函数类型说明为void  

**（2）有参函数**
* 有参数传递，一般需要带回函数值，例如`int max(int x,int y)`  

**（3）有参函数**
* 函数体只有一对花括号，花括号内没有任何语句，只起到占位的作用，方便后面添加函数

### 3.3 函数的声明和调用
#### 3.3.1 函数的声明
调用函数之前需要声明函数原型，在主调函数中或所有函数定义之前，按照如下形式声明：
```c
类型说明符 被调函数名(含类型说明的参数表)
```
如果是在所有函数定义之前声明了函数原型，那么该函数原型在本程序文件中任意地方都有效，但是要是在某个主调函数内部声明了函数原型，那么该原型就只在这个函数内部有效。  
下面对`js()`函数原型声明是合法的。
```c
int js(int n);
int js(int);//也是对的
```
#### 3.3.2 函数的调用
声明了函数原型后，我们便可以按照如下形式调用函数:
```c
函数名（实参列表） 
```
实参列表中应该给出与函数原型形参列表相同个数、类型相同的实参。在主调函数中的参数称为实参，实参一般具有确定的值，可以是常量，表达式，也可以是已有确定值的变量、数组或指针名。函数调用可以作为一条语句，此时函数可以无返回值；函数调用也可以出现在表达式中，这时就必须有一个明确的返回值。

#### 3.3.3 函数的返回值
-   函数返回值由`return`语句给出，一个函数只能有一个返回值。
-   返回值类型在函数定义时指定，如`int func()`返回整型，`void func()`表示无返回值。
-   若未指定返回值类型，默认是`int`。返回值可用于赋值、传参等后续操作。
- 函数的返回语句也可以是`return`，此时函数无返回值，而只是把流程转向主调函数。

### 3.4 函数的传值与传址调用
#### 3.4.1 函数的传值调用
**特点：** 将调用函数的实参表中的实参值依次传递给被调用函数的形参表中的形参。要求个数相等，类型相同。函数的调用过程实际上是对栈（在数据结构中会介绍）。  
传值调用是将实参的数据值传给形参，但是实参本身并不发生改变，简称 **单向值传递** ，下面以一个失败的$swap$函数举例：（$swap$意为交换，要交换两个数字的值）
```c
void swap(int a,int b){
	int temp=a;a=b;b=temp;//交换a和b的值
}
int main(){
	int c=1,d=2;
	swap(c,d);
	scanf("%d,%d",c,d);
	return 0;
}
```
当我们运行这个程序后，发现$c$和$d$依然是1和2，说明它们的值并没有被成功的交换，因为我们只是把$c$和$d$的**值**传递给了形式参数$a$和$b$，$c$和$d$本身没有发生任何变化，即实参的值未发生改变，交换失败。那么如何交换成功呢？

#### 3.4.2 函数的传址调用（可学完指针再来看）
顾名思义，传址调用就是传递的**地址**，我们知道数据在计算机内是通过**内存空间**存储的，每个元素都有它的一块**地址**，我们将实参的地址传递给形参，那么随着形参的地址交换，不就可以成功的把实际参数的地址也交换了吗？——确实如此：
```c
void swap(int &a,int &b){//&是取地址符，得到的是地址
	int temp=a;a=b;b=temp;//交换a和b的值
}
int main(){
	int c=1,d=2;
	swap(c,d);
	scanf("%d,%d",c,d);
	return 0;
}
```
可以发现输出结构确实变成了2和1，这就说明这个函数生效了。这就是函数的传址调用。

### 3.5 全局变量、局部变量以及其作用域
#### 3.5.1  全局变量
** 定义**
全局变量是在所有函数外部定义的变量。以下是一个简单示例：
```c
#include <stdio.h>
// 定义全局变量
int globalVar = 10;
void func() {
    // 在函数中可以访问全局变量
    printf("在 func 函数中，全局变量 globalVar 的值为: %d\n", globalVar);
}
int main() {
    // 在 main 函数中也可以访问全局变量
    printf("在 main 函数中，全局变量 globalVar 的值为: %d\n", globalVar);
    func();
    return 0;
}
```
在上述代码中，`globalVar` 就是一个全局变量，它定义在所有函数（`func` 和 `main`）之外。  
* **作用域**
- 全局变量的作用域是从它的定义位置开始，到整个源文件的结束。这意味着在定义位置之后的所有函数都可以直接访问和修改这个全局变量。不过，如果在其他源文件中想使用该全局变量，需要使用 `extern` 关键字进行声明。  
* **生命周期**
- 全局变量的生命周期是整个程序的运行期间。程序开始运行时，全局变量就被创建并分配内存空间；当程序结束时，全局变量所占的内存空间才会被释放。  
:::warning
由于全局变量可以被多个函数访问和修改，可能会导致程序的可维护性和可读性降低，也容易引发意外的副作用。比如多个函数同时修改全局变量，可能会让程序的状态变得难以跟踪和调试。
:::
#### 3.5.2  局部变量
* **定义**
局部变量是在函数内部或者代码块（如 `if`、`for`、`while` 等语句块）内部定义的变量。示例如下：
```c
#include <stdio.h>
void func() {
    // 定义局部变量
    int localVar = 20;
    printf("在 func 函数中，局部变量 localVar 的值为: %d\n", localVar);
}
int main() {
    func();
    // 下面这行代码会报错，因为 localVar 是 func 函数的局部变量，main 函数无法访问
    // printf("在 main 函数中访问 localVar: %d\n", localVar);
    return 0;
}
```
在 `func` 函数内部定义的 `localVar` 就是一个局部变量。
 * **作用域**
- 局部变量的作用域仅限于定义它的函数或者代码块内部。在函数或代码块外部，无法访问这个局部变量。例如在上面的代码中，`main` 函数就不能访问 `func` 函数内部定义的 `localVar`。

* **生命周期**
- 局部变量的生命周期从进入定义它的函数或代码块开始，到离开该函数或代码块结束。当程序执行到定义局部变量的位置时，系统会为该变量分配内存空间；当离开该函数或代码块时，系统会自动释放该变量所占的内存空间。
:::warning
局部变量可以避免不同函数之间的变量命名冲突，提高代码的安全性和可维护性。不同函数内部可以定义同名的局部变量，它们彼此独立，互不影响。
:::

:::danger
全局变量数组初始全部为0，局部变量值是随机的，要初始化初始值，局部变量受栈空间大小限制，大数组需要注意，但是全局变量则可以开大数组。
:::

### 3.6 函数的递归
何为递归？即第$n$项和前面几项的关系。以阶乘函数为例，一般来说，实现一个阶乘函数我们可能会考虑使用循环：
```c
// 定义阶乘函数
int factorial(int n) {
    // 用于存储阶乘结果的变量，初始化为 1
    int result = 1;
    // 如果输入的 n 小于 0，阶乘无定义，这里简单返回 1
    if (n < 0) {
        return 1;
    }
    // 使用 for 循环计算阶乘
    for (int i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}
```
但是不难注意到，阶乘的第$n$项和其第$n-1$项有着很显然的关系：
$$
factorial(n)=n*factorial(n-1)
$$
于是我们也可以把阶乘函数更加简洁的写成下面这个形式：
```c
// 递归实现阶乘函数
int factorial(int n) {
    if (n == 0) {
        return 1;// 基本情况：0 的阶乘为 1
    } 
    else {
        return n * factorial(n - 1);
    }
}
```
这就是递归的魅力。

**例题【[# P1255 数楼梯](https://www.luogu.com.cn/problem/P1255)】**  
此题主要是一个递归的思想，语言并不重要，由于用c实现需要高精度的知识，下面用Python解决：
::: code-group
```Python
n = int(input())
if (n == 0):
    print(0)
    exit(0)
a = [1, 1, 2]
for i in range(0, n):
    a[2] = a[0] + a[1]
    a[0] = a[1]
    a[1] = a[2]
    pass
print(a[0])
```

```C++
#include<bits/stdc++.h>
#define N 250//2000位够了，250*8
using namespace std;
int  f[3][N+10],g;
int n;
int main()
{
	f[0][N]=1;f[1][N]=1;scanf("%d",&n);if(!n){puts("0");return 0;}//0要特判
	for(int i=2;i<=n;i++)
	 for(int j=N;j>0;j--)
	  {
	 	f[i%3][j]=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)%100000000;
	    g=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)/100000000;//8个0，别漏了
	  }
	int j=1;
	while(!f[n%3][j]&&j<N) j++;//处理前导0
	for(int i=j;i<=N;i++)
	{
		if(i!=j){//一定别漏了前面这句
		if(f[n%3][i]<1e7) putchar(48);
		if(f[n%3][i]<1e6) putchar(48);
		if(f[n%3][i]<1e5) putchar(48);
		if(f[n%3][i]<1e4) putchar(48);
		if(f[n%3][i]<1e3) putchar(48);
		if(f[n%3][i]<1e2) putchar(48);
		if(f[n%3][i]<1e1) putchar(48);}//补足前导0
		printf("%d",f[n%3][i]);//输出
	}
}
```
:::

## 4.指针与链表

### 4.1 指针变量

#### 4.1.1 指针定义与初始化
**指针的概念：**   
- 指针是一个变量，其存储的是另外一个变量的内存地址。通过指针，我们可以**间接**访问和操作其他变量。  

**指针变量的定义与初始化：**  
- 定义指针变量的一般形式为：
```c
类型 *指针变量名;
```
例如`int *p`定义了一个指向`int`类型变量的指针`p`。我们将通过以下例子来看看指针和普通变量有什么不同：   
**1.普通变量定义：**   
```c
int a=3;
```
定义了变量$a$，是int类型，值为3。内存中有一块内存空间存放$a$的值，对$a$的操作就是直接到这个内存空间存取。内存空间的位置叫地址，存放3的地址可以用**取地址操作符**“&”对$a$运算得到：`&a`。  
**2.指针变量定义：**   
```c
int *p=NULL;
```
定义了一个指针变量$p$，其指向一个内存空间，里面存放的是一个内存地址。现在赋值为NULL（其实就是0，表示特殊的空地址）。   
**3.给指针变量$p$赋值：**
```c
p=&a;
```
即把$a$变量的内存空间地址给了$p$，显然，直接对$p$存取，操作的是地址。通过这个地址间接的操作，才是整数3。即前后分为3步：$p$是指针变量指向的是内存地址，内存地址指向的是数值3，而$a$自身就是一个内存地址，其直接指向3。我们输入$a$时用的是`scanf(“%d”,&a)`，而&就是取地址运算符，存储在相应的地址。而$p$的定义是`p=&a`，$p$不直接指向3，而指向$a$，$a$再指向3，所以我们需要再用间接运算符*，此时，`*p=3`。将整型变量$a$的地址赋予$p$有两种方式：  

- 1.指针变量初始化的方法
```c
int a;int *p=&a;//注意先后顺序，是将a的地址赋值给p 而非*p
```
- 2.赋值语句的的方法
```c
int a;int *p;p=&a;
```

:::warning
不允许把一个数赋予指针变量，故如下的赋值是错误的：
```c
int *p;p=1000;
```
被赋值的指针变量前不能再加“ $*$ ”说明符，故如下的赋值也是错误的：
```c
*p=&a;
```
:::
指针变量直接存取的是内存地址：
```c
printf("%d",p)//输出的可能是0x4097ce（地址位置）
```
间接存取的才是储存类型的值：
```c
printf("%d",*p)//正确输出值
```
指针变量和普通变量一样，使用之前不仅要定义说明，而且必须被赋予具体的值，**未经赋值的指针变量不能使用。**    
下面举一个简单的例子：  
**例：** 输入两个不同的数，通过指针对两个数进行相加和相乘，并输出
```c
#include <stdio.h>
int main(){
	int a,b,s,t,*pa,*pb;
	pa=&a;pb=&b;//pa和pb指向地址，用取地址符赋予他们地址
	a=10;b=20;
	s=*pa+*pb//实际上就是a+b，因为*pa=a，*pb=b
	t=*pa * *pb；
	printf("a=%d,b=%d\n",*pa,*pb);
	printf("s=%d,t=%d\n",s,t);
	return 0;
}
```

#### 4.1.2 指针的引用和运算
一般的，我们可以这样看指针（`int *p`）与普通变量的关系（`int a`）
  
  |指针与普通变量对比   |
  |----------------|
  |p ———————— &a|
  |*p ———————— a|
  |*p=3———————a=3 |

  
下面介绍一些运算：    
**1.指针变量的初始化**  
- （1）`int *p=NULL`，NULL是特殊的地址0，叫做零指针。
- （2）`int a；int *p=&a;`，p初始化为a的地址。
- （3）【C++中才有】`int *p=new(int);`，申请一个空间给p，*p的内容不确定。  

**2.指针变量的加减运算**   
指针变量的内容是内存地址，其有两个常用的运算：加法和减法，这两个运算一般都是配合**数组**操作的。  
**例：** 输入$N$个整数，使用指针变量访问输出。
::: code-group
```C
#include <stdio.h>
int a[101],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	int *p=&a[1];
	for(int i=1;i<=n;i++){
		printf("%d",*p);
		p++;
	}
	return 0;
}
```

```C++
#include <cstdio>
using namespace std;
int a[101],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	int *p=&a[1];
	for(int i=1;i<=n;i++){
		printf("%d",*p);
		p++;
	}
	return 0;
}
```
:::

:::tip
“p++”的意思是“广义的加1”，并不是p的值（地址）加上一个数字1，而是根据类型int增加sizeof(int)，即正好“跳过”了一个整数的空间，从而到达下一个整数。  
类似的：  
①“p- -”就是向前跳过一个整数的空间，达到前一个整数；  
②（p+3）就是指向后面第三个整数的地址。
:::

#### 4.1.3 无类型指针
有时候，一个指针根据不同情况，指向的内容是不同类型的值，我们可以先不明确它的类型，定义一个无类型指针，后面再根据需要使用强制类型转换的方法明确它的类型。  
**语法：**  `void *`   
**例：** 
```c
#include <stdio.h>
int main() {
    int num = 10;
    float f = 3.14;
    void *ptr;
    ptr = &num;  // 指向 int 类型变量
    printf("%d",*ptr);
    ptr = &f;    // 指向 float 类型变量
    printf("%d",*ptr);
    return 0;
}
```
#### 4.1.4 多重指针
指针自身也是一种数据类型，那么就应该有指针可以指向指针，这就叫做多重指针。  
**例：**  
```c
#include <stdio.h>
int main() {
    int num = 10;
    int *ptr = &num;  // 一级指针，指向 int 类型变量
    int **pptr = &ptr;  // 二级指针，指向一级指针 ptr
    printf("num 的值: %d\n", num);
    printf("通过一级指针访问 num 的值: %d\n", *ptr);
    printf("通过二级指针访问 num 的值: %d\n", **pptr);
    return 0;
}
```

### 4.2 指针与数组
#### 4.2.1 指针与数组的关系
指向数组的指针变量称为数组指针变量。一个数组是一块**连续的内存单元**组成的，**数组名就是这块连续内存单元的首地址**。一个数组元素的首地址就是指它所占有的几个内存单元的首地址。一个指针变量既可以指向一个数组，也可以指向一个数组元素。可以把数组名或第一个元素的地址赋予它。这样，如果要使指针变量指向第$i$号元素，可以把$i$元素的首地址赋予它，或把数组名加$i$赋予它。
#### 4.2.2 指向数组的指针
**一般形式：** 与普通的指针相同，为
```c
类型说明符 *指针变量名
```
其中类型说明符表示所指向数组的类型。  
引入了指针变量后，我们可以用两种方法访问数组元素：  
- （1）下标法：定义了`int a[5];int *pa=a`，用`pa[i]`的形式访问$a$的数组元素。
- （2）指针法：采用`*(pa+i)`的形式，用间接访问的方法来访问数组元素。  

::: code-group
```C
#include <stdio.h>
int main(){
	int a[5],i,*pa=a; //定义整型数组和指针，*pa=a可以在下一行单独写成pa=a
	for(i=0;i<5;i++){
		scanf("%d",a+i);//可写成pa+i或&a[i]
	}
	for(i=0;i<5;i++){
		printf("a[%d]=%d\n",i,*(a+i));
		//指针访问数组，可写成*(pa+i)或pa[i]或a[i]
	}
	return 0;
}
```

```C++
#include <cstdio>
using namespace std;
int main(){
	int a[5],i,*pa=a; //定义整型数组和指针，*pa=a可以在下一行单独写成pa=a
	for(i=0;i<5;i++){
		scanf("%d",a+i);//可写成pa+i或&a[i]
	}
	for(i=0;i<5;i++){
		printf("a[%d]=%d\n",i,*(a+i));
		//指针访问数组，可写成*(pa+i)或pa[i]或a[i]
	}
	return 0;
```
:::

:::tip
- ①需要注意的是，**数组名a**自身就是一个地址！所以可以由`pa=a`的写法！
- ②由①，可以直接拿a当指针用，a指向的是数组的开始元素，a+i是指向数组的第i个元素的指针。
- ③指针变量pa是变量，是可以变化的，但是数组名a是静态的变量名，不可以变！即pa=pa+2是合法的，指向pa往后两个的元素，但是a=a+2是不合法的。
- ④最早我们在使用scanf的时候其实就使用了指针，读入一个变量需要加取地址符号&传递给scanf函数一个指针。而对于数组，数组名就可以直接当作指针。
:::
#### 4.2.3 指针也可以看成数组名
在C语言中，这很麻烦，C++中我们可以直接用new int来为指针申请连续的内存空间，但是C语言不能这样做，C语言中我们使用malloc函数来分配指定大小的内存块，malloc函数返回指向该内存块起始地址的void*指针，通常需要将其转换为具体类型的指针。而C++中，用new int则会方便很多，具体到后面C++章节再详细介绍，下面以一个计算前缀和数组的例子作为动态数组的介绍：
**例：**
::: code-group
```C
#include <stdio.h>
#include <stdlib.h>
int main() {
    int n;
    int *a;  // 定义指针变量 a，后续当作数组使用
    scanf("%d", &n);
    // 动态分配 n + 1 个 int 类型的内存空间
    a = (int *)malloc((n + 1) * sizeof(int));
    if (a == NULL) {
        printf("内存分配失败\n");// 若内存分配失败，输出错误信息并终止程序
        return 1;
    }
    for (int i = 1; i <= n; i++) {scanf("%d", &a[i]);}
    for (int i = 2; i <= n; i++) {a[i] += a[i - 1];}
    for (int i = 1; i <= n; i++) {printf("%d ", a[i]);}
    printf("\n");
    free(a);// 释放动态分配的内存
    return 0;
}
```

```C++
#include <cstdio>
using namespace std;
int n;
int *a;//定义指针变量a，后面直接当数组名使用
int main(){
	scanf("%d",&n);
	a=new int[n+1];//申请了连续的n+1个int型空间
	for(int i=1;i<=n;i++){scanf("%d",&a[i]);}
	for(int i=2;i<=n;i++){a[i]+=a[i-1];}//i从2开始防止越界
	for(int i=1;i<=n;i++){printf("%d",a[i]);}
	delete []a;//释放申请的a的空间
	return 0;
```
:::

### 4.3 指针与字符串
#### 4.3.1 字符串的表示形式
在C语言中，我们可以用两种方法访问字符串。  
- （1）用字符数组存放一个字符串，然后输出该字符串。
```c
int main(){
	char str[]="I love China! ";
	printf("%s\n",str);
}
```
- （2）用字符指针指向一个字符串。可以不定义字符数组，而定义一个字符指针。用字符指针指向字符串中的字符。
```c
int main(){
	char *str="I love China! ";
	printf("%s\n",str);
}
```
在这里，我们没有定义字符数组，而是在程序中定义了一个字符指针变量str，用字符串"I love China! "对它进行初始化。C语言（事实上C++也是）对字符串常量是按照字符数组处理的，在内存中开辟了一个字符数组用来存放该字符串数量。对字符指针变量初始化，实际上是把字符串第一个元素的地址赋给str。有人认为str是一个字符串变量，以为在定义的时候把"I love China! "这几个字符赋给该字符串变量是不对的。   
实际上，`char *str="I love China! ";`   
等价于`char *str；str="I love China! ";`     
可以看到，str被定义为了一个**指针变量**，指向字符串数据，请注意：它只是指向了一个字符变量或其他字符类型数据，不能同时指向多个字符数据，更不是把"I love China! "这些字符存放到str中（指针变量只能存放地址）。只是把"I love China! "的第一个字符的地址赋给了指针变量str。  
在输出的时候，用`printf("%s\n",str);`    
其中%s是输出字符串时用的格式符，在输出项中给出字符指针变量名，则系统先输出它所指向的第一个字符数据，然后自动使str+1，直到遇到“\0”为止。  
:::tip
可以通过字符数组名或者字符指针变量输出一个字符串，但是对数值型数组，是不能这样做的！！
:::

#### 4.3.2 字符串指针作函数参数
将一个字符串从一个函数传递到另外一个函数，可以用地址传递的方法，即用字符串数组名作参数或用指向字符的指针变量作参数。在被调用的函数中可以改变字符串的内容，在主调函数中可以得到被改变了的字符串。   
**例：** 输入一个长度最大为100的字符串，以字符数组的方式储存，再将字符串倒序储存，输出倒序储存后的字符串。（用指针做） 
::: code-group
```C
#include <stdio.h>
#include <string.h>
// 交换两个字符的位置
void swapp(char *a, char *b) {//写成&a，&b也行，见C++写法
    char t;
    t = *a;
    *a = *b;
    *b = t;
}
void work(char *str) {
    int len = strlen(str);
    for (int i = 0; i <= len / 2; i++) {
        swapp(&str[i], &str[len - i - 1]);  // 传递字符地址进行交换
    }
}
int main() {
    char s[110];
	gets(s);//现在一般替换为fgets
    work(s);
    printf("%s\n", s);
    return 0;
}
```

```C++ 
#include <cstdio>
#include <cstring>
using namespace std;
void swapp(char &a,char &b){//交换两个字符的位置
	char t;
	t=a;
	a=b;
	b=t;
}
void work(char *str){
	int len=strlen(str);//原型是size_t strlen(const char * str)
	for(int i=0;i<=len/2;++i){swapp(str[i],str[len-i-1]);}//首尾交换
}
int main(){
	char s[110];
	char *str=s;
	gets(s);//现在一般替换为fgets
	work(str);
	printf("%s",s);
	return 0;
}
```
:::

### 4.4 指针与函数
#### 4.4.1 指针作为函数参数
我们在前面函数部分探讨函数传值调用和传址调用的时候就讨论过类似的问题。在函数章节中，我们把数字作为参数传入函数中，实际上就是使用了传递指针（即传递数组首地址）的方法。通过首地址，我们可以访问数组中的任意一个元素。  
对于指向其他变量类型的指针，我们可以用同样的方式处理。我们再次来探讨一遍关于swap函数的例子。  
```c
void swap(int *x,int *y){
	int t=*x;
	*x=*y;
	*y=t;
}
```
这时，我们可以在其他函数中使用这个函数：
```c
int a=5,b=3;
swap(&a.&b);
printf("a=%d,b=%d",a,b);
//输出结果为a=3,b=5
```
在这个过程中，我们先将a和b的地址传给函数，然后在函数中通过地址得到变量a和b的值，并且对它们进行修改。当退出函数时，a和b的值就已经交换了。  
这里有一点值得我们注意，这点在上面的函数章节已经提过了，不加$*$和&的话a和b的值并不会互换。因为形参和实参的关系。我们不使用指针的话，交换的只是传递给形参的值，主调函数中的实参值并不会交换。  
#### 4.4.2 函数返回指针
一个函数可以返回字符值、整数值、实型值等，也可以返回指针联系的数据（即地址）。  
返回指针值的函数的一般定义形式为：  
```c
类型名 * 函数名(参数列表)；
//例如：
int *a(int a,int b)
```
a是函数名，调用它后得到了一个指向整型数据的指针（地址）。x和y是函数a的形参，为整型。
:::warning
在*a的两侧没有括号；在a的两侧分别为$*$运算符和（）运算符，由于（）的优先级高于$*$，a先与（）结合。在函数面前有一个$*$表示此函数是返回指针类型的函数，前面的int表示返回的指针指向整型变量。这点容易搞错。
:::

### 4.5 函数指针和函数指针数组
一个指针变量通过指向不同的整型变量的地址，就可以对其他的变量操作。  
程序中不仅数据是存放在内存空间中，代码也同样存放在内存空间中。具体讲，C和C++的函数也保存在内存中，函数的入口地址也同样可以使用指针来访问。  
另一方面，有些函数在编写时对要调用的辅助函数尚未确定，在执行时才能根据情况为其传递辅助函数的地址。比如在C语言中，qsort函数的调用：`qsort(arr,n,sizeof(int),cmp)`，其中的cmp函数是我们根据需要传给sort的，其实就是传递了函数指针。  
**函数指针的基本操作有3个：**   
- （1）声明函数指针    
声明要指定函数的返回类型以及函数的参数列表，和函数原型差不多。**例如：**
```c
int test(int); //函数的原型
int (*fp)(int); //相应的指针声明
//要注意不能写成：
int *fp(int);//写成这样计算机会处理成声明一个fp(int)的函数，返回类型为int*
```
- （2）获取函数地址
获取函数地址很简单，只需使用函数名即可，例如，`fp=test`。  
这表明函数名和数组名一样，可以看作是指针。   
- （3）使用函数指针来调用函数  
类似普通变量指针，可以用`(*fp)`来间接调用指向的函数，但C++也允许像使用函数名一样使用fp。**（C语言不允许）**     
函数指针还有另一种结合typedef的声明方式：
**例：**
::: code-group
```C
#include <stdio.h>
int sum(int a, int b) {
    return a + b;
}
// 使用typedef定义函数指针类型，该函数指针指向的函数有两个int型参数，返回值为int型
typedef int (*LP)(int, int); 
int main() {
    LP p = add; // 定义函数指针变量并指向add函数
    int result = p(2, 5); // 通过函数指针调用函数
    printf("%d\n", result); //输出7
    return 0;
} 
```
```C++
#include <iostream>
using namespace std;
int sum(int a, int b) {
    return a + b;
}
// 使用typedef定义函数指针类型，该函数指针指向的函数有两个int型参数，返回值为int型
typedef int (*LP)(int, int); 
int main() {
    LP p = add; // 定义函数指针变量并指向add函数
    cout<<p(2,5);
    return 0;
} 
```
:::

## 5.结构体
### 5.1 结构体的定义和操作
#### 5.1.1定义结构体及结构体变量
- （1）定义结构体类型的时候同时定义变量：  
```c
struct 结构体类型名{    //其中struct为关键字
	成员表;			//可以有多个成员
	成员函数;		//可以有多个函数，也可以没有
}结构体变量;			//可以同时定义多个结构体变量，用“，”隔开  
//例如：
struct student{
	char name;
	int chinese,math;
	int total;
}a[110]; 		//	同时定义了a数组变量
```
- （2）先定义结构体再定义结构体变量：  
```c
struct 结构体类型名{
	成员表;
	成员函数;
}；
结构体名 结构体变量表		//可以同时定义多个结构体变量
//例如：
struct student{
	char name;
	int chinese,math;
	int total;
};
student a[110];
```
:::tip 注意
在定义结构体变量时，结构体变量名与结构体名不能相同，在定义结构体时，系统对其不分配实际内存。只有定义结构体变量时，系统才为其分配内存。
:::
#### 5.1.2 结构体变量的特点
- （1）结构体变量可以整体操作，例如：
 ```c
swap(a[j],a[j+1]);
```
- （2）结构体变量的成员访问也很方便，清晰，例如：
:::code-group
```C
scanf("%s",&a[i].name);
```
```C++
cin>>a[i].name;
```
:::

- （3）结构体变量的初始化和数组的初始化类似，例如：
```c
student op={"yuanshen",60,80,100};
```
#### 5.1.3 成员调用
结构体变量与各个成员之间的引用形式一般为：
```c
	结构体变量名.成员名
```
对于上面定义的结构体变量，我们可以这样操作：
:::code-group
```C
scanf("%s",a[i].name);
a[i].total=a[i].chinese+a[i].math;
```
```C++
cin>>a[i].name;
a[i].total=a[i].chinese+a[i].math;
```
:::
实际上结构体成员的操作与该成员类型所具有的操作是一致的。  
成员运算符“$.$”在存取成员数值时使用，其优先性最高，有左结合性。在处理**包含结构体的结构体**时，可记作：
```c
strua.strub.membb;
```
这说明结构体变量srtua有结构体成员strub，结构体变量strub有成员membb。
#### 5.1.4 成员函数调用
结构体成员函数调用的一般形式为：
```c
	结构体变量名.成员函数;
```
结构体成员函数默认将结构体变量作为引用参数。  

### 5.2 结构体与指针
#### 5.2.1 结构体指针的定义与使用
当一个指针变量指向一个结构体变量时，称之为结构体指针变量。  
结构体指针变量的值是所指向的结构体变量的起始地址。通过结构体指针即可访问结构体变量——这与数组指针和函数指针的情况是相同的。  
结构体指针变量定义的一般形式：  
```c
结构体名 *结构体指针变量名
```
当然也可以在定义结构体的同时定义这个结构体指针变量。  
**例**
:::code-group
```c[写法1]
struct student{
	char name[20];
	char sex;
	float score;
}*p;
```
```c[写法2]
struct student{
	char name[20];
	char sex;
	float score;
};
student *p;
```
与前面讨论的各类指针变量相同，结构体指针变量也需要赋值后才能使用，赋值是把结构体变量的首地址赋予该变量，不能把结构体名赋予该指针变量。  
**例如：** 如果p是被定义为student类型的结构体变量，boy是被定义为student类型的结构体变量，则：`p=&boy`是正确的，而`p=&student`是错误的！  
引入结构体指针变量指向的结构体变量的成员的方法如下：   
- 指针名->成员名
- (*指针名).成员名

::: info 示例
(*p).score与p->score是等价的
:::

#### 5.2.2 自引用结构
在一个结构体内部包含一个类型为结构体本身的成员是否合法呢？
```c
struct stu{
	char name[20];
	int age,score;
	stu p;
};
```
**注意：像上面这种自引用是非法的！这类似于一种无穷递归。**    
但是像下面这种自引用是合法的：
```c
struct stu{
	char name[20];
	int age,score;
	stu *p;
};
```
这种声明和上面的不同之处在于现在的p是一个指针，而不是结构体。编译器在结构体的长度之前就已经知道指针的长度，所以这种类型的自引用当然是合法的。  
这种自引用是实现其他一些结构的基础。自引用在动态数据结构中有重要的应用，甚至可以说，自引用结构是C/C++实现动态数据结构的基石。包括动态的链表，堆，栈，树，无不是自引用的具体实现。

## 6.C语言课后作业题
### 6.1 数据类型、运算符与表达式
#### 6.1.1 计算平均值
**【问题描述】**   
从键盘输入三个整数，分别存入x,y,z三个整型变量中，计算并输出三个数的和以及平均值。  
**【输入形式】**   
从键盘输入三个整数，整数之间以空格隔开。  
**【输出形式】**   
在屏幕上分两行显示结果：  
第一行为三个数的和，整数形式输出；  
第二行为三个数的平均值，浮点数形式输出，小数点后保留两位小数。
::: details 答案
```c
#include <stdio.h>
int main(){
int x, y, z;
int sum;
double average;
scanf("%d%d%d", &x, &y, &z);
sum = x + y + z;
average = (double)sum / 3;
printf("%d\n", sum);
printf("%.2f", average);
return 0;
}
```
 :::
#### 6.1.2 求三角形面积
**【问题描述】**  
若已知三角形三个边的长度分别为a,b,c（并假设三个边长度的单位一致，在本编程题中忽略其单位），则可以利用公式:  
$$
S=\sqrt{s(s - a)(s - b)(s - c)}
$$
求得三角形的面积，其中：$s=\frac{(a+b+c)}{2}$。编程实现从控制台读入以整数表示的三个边的长度（假设输入的长度肯定可以形成三角形），然后利用上述公式计算面积并输出，结果小数点后保留3位有效数字。  
**【输入形式】**  
从控制台输入三个整数表示三角形三个边的长度，以空格分隔三个整数。  
**【输出形式】**  
向控制台输出求得的三角形的面积，小数点后保留三位有效数字。
::: details 答案
```c
#include <stdio.h>
#include <math.h>
int main(){
int a,b,c;
double s,area;
scanf("%d%d%d",&a,&b,&c);
s=(a+b+c)/2.0;
area=sqrt(s*(s-a)*(s-b)*(s-c));
printf("%.3f",area);
}
```
 :::
#### 6.1.3 摄氏华氏温度转换
**【问题描述】**  
假如用C表示摄氏温度，F表示华氏温度，则有：$F = C\times\frac{9}{5}+32$。输入一整数表示摄氏温度，根据该公式编程求对应的华氏温度，结果小数点后保留一位有效数字。   
**【输入形式】**  
从控制台读入一个整数，表示摄氏温度。   
**【输出形式】**   
向控制台输出转换后的华氏温度，结果小数点后保留一位有效数字。 
::: details 答案
```c
#include <stdio.h>
int main(){
int C;
float F;
scanf("%d",&C);
F=C*9.0/5.0+32.0; //注意浮点数运算！不要写成整数了 // [!code warning]
printf("%.1f",F);
return 0;
}
```
 :::
#### 6.1.4 前驱、后继字符
**【问题描述】**  
从键盘输入一个字符，求出它的前驱和后继字符（按照ASCII码值排序），并按照从小到大的顺序输出这三个字符和对应的ASCII值。  
**【输入形式】**  
从键盘输入一个字符  
**【输出形式】**  
按两行输出：  
第一行按照从小到大的顺序输出这三个字符，并以一个空格隔开；  
第二行按照从小到大的顺序输出三个字符对应的ASCII值，并以一个空格隔开。
::: details 答案
```c
#include <stdio.h>
int main(){
char ch;
scanf("%c", &ch);
printf("%c %c %c\n", ch-1, ch, ch+1);
printf("%d %d %d", ch-1, ch, ch+1);//这样可以直接输出ASCII码 // [!code warning]
return 0;
}
```
 :::

 ### 6.2 流程控制
#### 6.2.1    找最大最小整数
**【问题描述】**      
编写一个程序，用户输入若干整数，试找出其中的最大数和最小数。    
**【输入形式】**    
用户在第一行待输入数据个数，在第二行输入数据。     
**【输出形式】**     
程序在下一行输出数据的最大值和最小值    
::: details 答案
```c
#include <stdio.h>
int main(){
	int n, a[n + 5], i;
	scanf("%d", &n);
	for (i = 0; i < n; i++){
		scanf("%d", &a[i]);
	}
	int max = 0, min = 1000000;
	for (i = 0; i < n; i++){
		if (a[i] > max){
		max = a[i];
		}
		if (a[i] < min){
		min = a[i];
		}
	}
	printf("%d %d", max, min);
	return 0;
}
```
 :::

#### 6.2.2    工资
**【问题描述】**    
假设税前工资和税率如下（s代表税前工资，t代表税率）：    
s<1000  t=0%    
1000<=s<2000 t=10%    
2000<=s<3000 t=15%    
3000<=s<4000 t=20%    
4000<=s t=25%    
编写一程序，要求用户输入税前工资额，然后用switch语句计算税后工资额。    
**【输入形式】**    
从键盘输入税前工资s，可以是浮点数。    
**【输出形式】**    
输出税后工资额，保留小数后两位。  
::: details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    float s;
    scanf("%f", &s);
    int category;
    if (s < 1000){category = 0;}
    else if (s < 2000){category = 1;}
    else if (s < 3000){category = 2;}
    else if (s < 4000){category = 3;}
    else{category = 4;}
    float taxRate;
    switch (category){
    case 0:
        taxRate = 0;
        break;
    case 1:
        taxRate = 0.1;
        break;
    case 2:
        taxRate = 0.15;
        break;
    case 3:
        taxRate = 0.2;
        break;
    case 4:
        taxRate = 0.25;
        break;
    default:
        break;
    }
    float afterTaxSalary = s * (1 - taxRate);
    printf("%.2f\n", afterTaxSalary);
    return 0;
}
```
 :::

#### 6.2.3 求和
**【问题描述】**  
编写一个程序，求s=1+(1+2)+(1+2+3)+...+(1+2+3+...+n)。    
**【输入形式】**    
输入一个正整数n，根据求s公式计算s并输出。    
**【输出形式】**    
输出的为s的结果。   
::: details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int sum(n){
    return n * (n + 1) / 2;
}
int main(){
    int n, s = 0, i;
    scanf("%d", &n);
    for (i = 1; i <= n; i++){
        s += sum(i);
    }
    printf("%d", s);
    return 0;
}
```
 :::
 
 #### 6.2.4 简易计算器
 **【问题描述】**  
编程实现简易的计算器：读入两个整数运算数(data1和data2)及一个运算符(op)，计算表达式data1 op data2的值，其中op可以是+,-,$*$,/。  
 **【输入形式】**   
控制台输入运算数和运算符:    
1.首先输入以空格分隔的两个整数，分别是data1和data2；    
2.输入一个字符作为运算符op，op可以是'+'，'-'，'$*$'，'/'。    
输入时，data1、data2、op之间各留有一个空格。具体格式见样例输入。  
 **【输出形式】**   
控制台输出运算结果。作除法运算时，若能够整除，则输出为整数，否则输出结果小数点后应保留两位有效数字。   
::: details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int main(){
    int data1, data2;
    char op;
    scanf("%d %d %c", &data1, &data2, &op);
    switch (op){
    case '+':
        printf("%d", data1 + data2);
        break;
    case '-':
        printf("%d", data1 - data2);
        break;
    case '*':
        printf("%d", data1 * data2);
        break;
    case '/':
        if (data1 % data2 == 0){
            printf("%d", data1 / data2);
        }
        else{
            printf("%.2f", (float)data1 / data2);
        }
        break;
    default:
        break;
    }
    return 0;
}
```
 :::

 #### 6.2.5 同构数
  **【问题描述】**  
具有下面性质的数a称为"同构数"：设b是a的平方，a与b的低若干位相同。例如，5是25的同构数,25是625的同构数.编程序满足如下要求:    
输入两个整数a,b (0<=a, b<=99),找出a、b之间全部的同构数。    
 **【输入形式】**  
控制台输入0-99之间的两个整数a和b.    
 **【输出形式】**   
控制台上按照由小到大的顺序输出所有同构数.每一个整数占一行.    
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    int a, b, num, square;
    scanf("%d %d", &a, &b);
    for (num = a; num <= b; num++)
    {
        square = num * num;
        if (num < 10)
        {
            if (square % 10 == num)
            {
                printf("%d\n", num);
            }
        }
        else
        {
            if (square % 100 == num)
            {
                printf("%d\n", num);
            }
        }
    }
    return 0;
} 
```
:::

 #### 6.2.6 求水仙花数
 **【问题描述】**  
编写一个程序，输入一个正整数N(N大于等于100小于等于999)，求出100~N之间的所有水仙花数。所谓 的水仙花数是：如果一个三位数的个位数、十位数、百位数的立方和等于该数自身，就称这个数为水仙花数。    
 **【输入形式】**   
输入一个正整数N。    
 **【输出形式】**   
输出从100到N之间的所有水仙花数，每个数以回车结束。   
:::details 答案
```c
#include <stdio.h>
int main()
{
    int N, num, hundreds, tens, units;
    scanf("%d", &N);
    for (num = 100; num <= N; num++)
    {
        hundreds = num / 100;
        tens = (num % 100) / 10;
        units = num % 10;
        if (hundreds * hundreds * hundreds + tens * tens * tens + units * units * units == num)
        {
            printf("%d\n", num);
        }
    }
    return 0;
}
```
:::

 #### 6.2.7 整数求和
**【问题描述】**    
输入2个正整数a和n，求a+aa+aaa+...+aa...a（n个a）。不考虑整数溢出情况。  
**【输入形式】**   
从标准输入中读入两个以空格分隔的正整数（大于等于1，小于等于9）。  
**【输出形式】**   
在标准输出中输出整数相加式及结果和。运算符（+, =）与整数之间用一个空格分隔。   
:::details 答案
```c
#include <stdio.h>
int main()
{
    int a, n, i, temp, result = 0;
    scanf("%d %d", &a, &n);
    printf("%d", a);
    temp = a;
    result = a;
    for (i = 1; i < n; i++)
    {
        temp = temp * 10 + a;
        printf(" + %d", temp);
        result += temp;
    }
    printf(" = %d", result);
    return 0;
}
```
:::


 #### 6.2.8 求A,B
 **【问题描述】**   
输入三位数字N，求两位数AB（其中个位数字为B，十位数字为A，且有0 < A < B &le;9）。使得下列等式成立：    
AB x BA = N    
其中BA是把AB中个、十位数字交换所得的两位数。     
编写程序，接收控制台输入的三位整数N，求解A，B并输出。    
如果没有解则输出"No Answer"。    
 **【输入形式】**     
从键盘输入整数N。     
 **【输出形式】**   
输出只有一行，包含两个数字A和B。输出时两个数字紧密输出，不使用其它字符进行分隔。   
:::details 答案
```c
#include <stdio.h>
int main()
{
    int N, A, B, num1, num2, found = 0;
    scanf("%d", &N);
    for (A = 1; A < 9; A++)
    {
        for (B = A + 1; B < 10; B++)
        {
            num1 = 10 * A + B;
            num2 = 10 * B + A;
            if (num1 * num2 == N)
            {
                printf("%d%d", A, B);
                found = 1;
                break;
            }
        }
        if (found)
        {
            break;
        }
    }
    if (!found)
    {
        printf("No Answer");
    }
    return 0;
}
```
:::


 #### 6.2.9 最大公约数和最小公倍数
 **【问题描述】**   
输入两个正整数a和b（0<a，b<1000000），求出其最大公约数和最小公倍数并输出。    
**【输入文件】**  
从标准输入读取一行，是两个整数a和b，以空格分隔。   
**【输出文件】**   
向标准输出打印以空格分隔的两个整数，分别是a、b的最大公约数和最小公倍数。在输出末尾要有一个回车符。   
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
int gcd(int a, int b)
{
    return b == 0 ? a : gcd(b, a % b);
}
int lcm(int a, int b)
{
    return a * b / gcd(a, b);
}
int main()
{
    int x, y;
    scanf("%d %d", &x, &y);
    printf("%d %d\n", gcd(x, y), lcm(x, y));
    return 0;
}
```
:::
#### 6.2.10 比较两组整数（新）
**【问题描述】**   
比较两组整数是否有相同的元素，每组整数个数不超过100。若有相同的元素，则按照由大到小的顺序输出相同的元素（重复出现的元素只输出一个）。如果没有相同元素，打印字符串：No Answer。   
**【输入形式】**   
首先从标准输入（键盘）输入第一组整数的个数，再输入第一组整数，以一个空格分割；然后输入第二组整数的个数，再输入第二组整数，以一个空格分割。  
**【输出形式】**   
按照由大到小的顺序向标准输出（显示器）输出两组整数中相同的元素，以一个空格分隔；如果没有相同元素，则打印"No Answer"。   
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    int i, j;
    for (i = 0; i < n-1; i++) {
        for (j = 0; j < n-i-1; j++) {
            if (arr[j] < arr[j+1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
int main() {
    int n1, n2, arr1[MAX_SIZE], arr2[MAX_SIZE];
    int i, j, count = 0, common[MAX_SIZE];
    // 读取第一个数组
    scanf("%d", &n1);
    for (i = 0; i < n1; i++) {
        scanf("%d", &arr1[i]);
    }
    // 读取第二个数组
    scanf("%d", &n2);
    for (i = 0; i < n2; i++) {
        scanf("%d", &arr2[i]);
    }
    // 找出两个数组中的共同元素，并去重
    for (i = 0; i < n1; i++) {
        for (j = 0; j < n2; j++) {
            int isDuplicate = 0;
            if (arr1[i] == arr2[j]) {
                int k;
                for (k = 0; k < count; k++) {
                    if (common[k] == arr1[i]) {
                        isDuplicate = 1;
                        break;
                    }
                }
                if (!isDuplicate) {
                    common[count++] = arr1[i];
                }
            }
        }
    }
    // 如果没有共同元素，输出 "No Answer"
    if (count == 0) {
        printf("No Answer");
    } else {
        // 使用冒泡排序对共同元素进行降序排序
        bubbleSort(common, count);
        // 输出排序后的共同元素
        for (i = 0; i < count; i++) {
            if (i != 0) {
                printf(" ");
            }
            printf("%d", common[i]);
        }
    }
    return 0;
}
```
:::
### 6.3 数组
#### 6.3.1 在数组中插入新元素
**【问题描述】**  
现有一个数组{1,4,6,9,13,16,19,28,40,100}，用户输入一个数字，要求按照原数组的排序方式将用户输入的数字插入到数组中并输出新数组。  
**【输入形式】**  
输入一个整数   
**【输出形式】**  
输出新的排序完成的数组  
:::details 答案
```c
#include <stdio.h>
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main() {
    int arr[11] = {1, 4, 6, 9, 13, 16, 19, 28, 40, 100};
    int num;
    // 输入要插入的数字
    scanf("%d", &num);
    // 将输入的数字放入数组的最后一个位置
    arr[10] = num;
    // 使用冒泡排序对数组进行升序排序
    bubbleSort(arr, 11);
    // 输出排序后的数组
    for (int i = 0; i < 11; i++) {
        printf("%d ", arr[i]);
    }
    return 0;
}
```
:::
 
 #### 6.3.2   字符串中字符排序
 **【问题描述】**   
编写一个程序，从键盘接收一个字符串，然后按照字符顺序从小到大进行排序，并删除重复的字符。     
**【输入形式】**    
用户在第一行输入一个字符串。    
**【输出形式】**   
程序按照字符(ASCII)顺序从小到大排序字符串，并删除重复的字符进行输出。   
:::details 答案
```c
#include <stdio.h>
#include <string.h>
// 冒泡排序函数
void bubbleSort(char arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换字符
                char temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main() {
    char str[1000]; // 假设输入的字符串长度不超过 1000
    scanf("%s", str);
    int len = strlen(str);
    // 使用冒泡排序对字符串进行排序
    bubbleSort(str, len);
    // 去重并生成结果字符串
    char result[1000];
    int resultIndex = 0;
    for (int i = 0; i < len; i++) {
        if (i == 0 || str[i] != str[i - 1]) {
            result[resultIndex++] = str[i];
        }
    }
    result[resultIndex] = '\0'; // 添加字符串结束符
    // 输出结果
    printf("%s\n", result);
    return 0;
}
```
:::

 #### 6.3.3   判断两个数据集是否相同
 **【问题描述】**   
从标准输入中读入两个整数集，整数集中数据无序，且可能有重复数据。当两个数据集中数据完全相同（数据相同，数据若重复，重复个数也相同，顺序不一定相同），则两个数据集相同。编写一程序判断输入的两数据集是否相同：用1表示相同，用0表示不同。   
**【输入形式】**   
先输入第一组整数集的个数（大于等于1，小于等于20），然后输入第一组整数（以一个空格分隔）；再输入第二组整数集的个数（大于等于1，小于等于20），并输入第二组整数（以一个空格分隔）。   
**【输出形式】**   
若两数据集相同，则输出1，否则输出0，然后按照从小到大的顺序分行输出第一个数据集中的数据及重复个数（以一个空格分隔数据和重复个数）。   
:::details 答案
```c
#include <stdio.h>
#include <stdlib.h>
// 冒泡排序函数
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
// 统计数组中每个元素的重复次数
void countDuplicates(int arr[], int n, int counts[]) {
    for (int i = 0; i < n; i++) {
        counts[i] = 1;
    }
    for (int i = 0; i < n; i++) {
        if (arr[i] != -1) {
            for (int j = i + 1; j < n; j++) {
                if (arr[i] == arr[j]) {
                    counts[i]++;
                    arr[j] = -1; // 标记为已处理
                }
            }
        }
    }
}
// 比较两个数组是否相同
int compareArrays(int arr1[], int counts1[], int n1, int arr2[], int counts2[], int n2) {
    if (n1 != n2) {
        return 0;
    }
    for (int i = 0; i < n1; i++) {
        if (arr1[i] != arr2[i] || counts1[i] != counts2[i]) {
            return 0;
        }
    }
    return 1;
}
int main() {
    int n1, n2;
    int arr1[20], arr2[20];
    int counts1[20], counts2[20];
    // 读取第一个数组
    scanf("%d", &n1);
    for (int i = 0; i < n1; i++) {
        scanf("%d", &arr1[i]);
    }
    // 读取第二个数组
    scanf("%d", &n2);
    for (int i = 0; i < n2; i++) {
        scanf("%d", &arr2[i]);
    }
    // 对两个数组进行排序
    bubbleSort(arr1, n1);
    bubbleSort(arr2, n2);
    // 统计每个数组中元素的重复次数
    countDuplicates(arr1, n1, counts1);
    countDuplicates(arr2, n2, counts2);
    // 比较两个数组是否相同
    int result = compareArrays(arr1, counts1, n1, arr2, counts2, n2);
    printf("%d\n", result);
    // 输出第一个数组的元素及其重复次数
    for (int i = 0; i < n1; i++) {
        if (arr1[i] != -1) {
            printf("%d %d\n", arr1[i], counts1[i]);
        }
    }
    return 0;
}
```
:::

 #### 6.3.4   旋转矩阵
 **【问题描述】**   
从标准输入中输入两个N（N<=9）阶矩阵，判断第二个矩阵是否是第一个矩阵的旋转矩阵，并输出旋转角度，若不是则输出-1。一个矩阵若是另一个矩阵通过顺时针旋转0度、90度、180度或270度得到，则该矩阵是旋转矩阵。   
**【输入形式】**   
从标准输入读取矩阵。   
第一行只有一个整数N，代表两个矩阵的阶数。   
然后在后续N行上输入第一个矩阵，每行有N个以若干空格分隔的整数，代表该矩阵在该行上的所有元素。   
输入第一个矩阵后，再在后续的N行上输入第二个矩阵，每行有N个以若干空格分隔的整数，代表该矩阵在该行上的所有元素。   
**【输出形式】**    
若第二个矩阵是第一个矩阵的旋转矩阵，则输出旋转角度（取值为0、90、180或270），若不是则输出－1。    
:::details 答案
```c
#include <stdio.h>
int isEqual(int matrix1[9][9], int matrix2[9][9], int n);
void rotate90(int matrix[9][9], int n);
void rotate180(int matrix[9][9], int n);
void rotate270(int matrix[9][9], int n);
int main()
{
    int n, i, j;
    int matrix1[9][9], matrix2[9][9];
    scanf("%d", &n);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &matrix1[i][j]);
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            scanf("%d", &matrix2[i][j]);
    if (isEqual(matrix1, matrix2, n))
    {
        printf("0\n");
        return 0;
    }
    int tempMatrix[9][9];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            tempMatrix[i][j] = matrix1[i][j];
    rotate90(tempMatrix, n);
    if (isEqual(tempMatrix, matrix2, n))
    {
        printf("90\n");
        return 0;
    }
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            tempMatrix[i][j] = matrix1[i][j];
    rotate180(tempMatrix, n);
    if (isEqual(tempMatrix, matrix2, n))
    {
        printf("180\n");
        return 0;
    }
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            tempMatrix[i][j] = matrix1[i][j];
    rotate270(tempMatrix, n);
    if (isEqual(tempMatrix, matrix2, n))
    {
        printf("270\n");
        return 0;
    }
    printf("-1\n");
    return 0;
}
int isEqual(int matrix1[9][9], int matrix2[9][9], int n)
{
    int i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            if (matrix1[i][j] != matrix2[i][j])
                return 0;
    return 1;
}
void rotate90(int matrix[9][9], int n)
{
    int temp[9][9], i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            temp[j][n - 1 - i] = matrix[i][j];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            matrix[i][j] = temp[i][j];
}
void rotate180(int matrix[9][9], int n)
{
    int temp[9][9], i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            temp[n - 1 - i][n - 1 - j] = matrix[i][j];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            matrix[i][j] = temp[i][j];
}
void rotate270(int matrix[9][9], int n)
{
    int temp[9][9], i, j;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            temp[n - 1 - j][i] = matrix[i][j];
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            matrix[i][j] = temp[i][j];
}
```
:::

 #### 6.3.5     求两组整数的并集
 **【问题描述】**  
从标准输入中输入两组整数(每组不超过20个整数，每组整数中元素不重复)，合并两组整数，重复的整数只出现一次，并按从大到小顺序排序输出（即两组整数集的"并集"）。  
**【输入形式】**  
首先输入第一组整数的个数，然后在下一行输入第一组整数，以一个空格分隔各个整数；再在新的一行上输入第二组整数的个数，然后在下一行输入第二组整数，以一个空格分隔。  
**【输出形式】**   
按从大到小顺序排序输出合并后的整数集（以一个空格分隔各个整数，最后一个整数后的空格可有可无）。   
:::details 答案
```c
#include <stdio.h>
// 冒泡排序函数（从大到小排序）
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] < arr[j + 1]) {
                // 交换元素
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
int main() {
    int n1, n2;
    int arr1[20], arr2[20], result[40]; // 最多20个元素，合并后最多40个
    int count = 0; // 记录合并后数组的长度
    // 读取第一个数组
    scanf("%d", &n1);
    for (int i = 0; i < n1; i++) {
        scanf("%d", &arr1[i]);
    }
    // 读取第二个数组
    scanf("%d", &n2);
    for (int i = 0; i < n2; i++) {
        scanf("%d", &arr2[i]);
    }
    // 将第一个数组的元素加入结果数组
    for (int i = 0; i < n1; i++) {
        int isDuplicate = 0;
        for (int j = 0; j < count; j++) {
            if (arr1[i] == result[j]) {
                isDuplicate = 1;
                break;
            }
        }
        if (!isDuplicate) {
            result[count++] = arr1[i];
        }
    }
    // 将第二个数组的元素加入结果数组
    for (int i = 0; i < n2; i++) {
        int isDuplicate = 0;
        for (int j = 0; j < count; j++) {
            if (arr2[i] == result[j]) {
                isDuplicate = 1;
                break;
            }
        }
        if (!isDuplicate) {
            result[count++] = arr2[i];
        }
    }
    // 对结果数组进行从大到小排序
    bubbleSort(result, count);
    // 输出结果
    for (int i = 0; i < count; i++) {
        printf("%d", result[i]);
        if (i < count - 1) {
            printf(" ");
        }
    }
    printf("\n");
    return 0;
}
```
:::
